// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: tero/policy/v1/trace.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// TraceField identifies simple span fields (non-keyed).
type TraceField int32

const (
	TraceField_TRACE_FIELD_UNSPECIFIED TraceField = 0
	// Span fields
	TraceField_TRACE_FIELD_NAME           TraceField = 1
	TraceField_TRACE_FIELD_TRACE_ID       TraceField = 2
	TraceField_TRACE_FIELD_SPAN_ID        TraceField = 3
	TraceField_TRACE_FIELD_PARENT_SPAN_ID TraceField = 4
	TraceField_TRACE_FIELD_TRACE_STATE    TraceField = 5
	// Schema URLs
	TraceField_TRACE_FIELD_RESOURCE_SCHEMA_URL TraceField = 10
	TraceField_TRACE_FIELD_SCOPE_SCHEMA_URL    TraceField = 11
	// Scope fields (InstrumentationScope)
	TraceField_TRACE_FIELD_SCOPE_NAME    TraceField = 12
	TraceField_TRACE_FIELD_SCOPE_VERSION TraceField = 13
)

// Enum value maps for TraceField.
var (
	TraceField_name = map[int32]string{
		0:  "TRACE_FIELD_UNSPECIFIED",
		1:  "TRACE_FIELD_NAME",
		2:  "TRACE_FIELD_TRACE_ID",
		3:  "TRACE_FIELD_SPAN_ID",
		4:  "TRACE_FIELD_PARENT_SPAN_ID",
		5:  "TRACE_FIELD_TRACE_STATE",
		10: "TRACE_FIELD_RESOURCE_SCHEMA_URL",
		11: "TRACE_FIELD_SCOPE_SCHEMA_URL",
		12: "TRACE_FIELD_SCOPE_NAME",
		13: "TRACE_FIELD_SCOPE_VERSION",
	}
	TraceField_value = map[string]int32{
		"TRACE_FIELD_UNSPECIFIED":         0,
		"TRACE_FIELD_NAME":                1,
		"TRACE_FIELD_TRACE_ID":            2,
		"TRACE_FIELD_SPAN_ID":             3,
		"TRACE_FIELD_PARENT_SPAN_ID":      4,
		"TRACE_FIELD_TRACE_STATE":         5,
		"TRACE_FIELD_RESOURCE_SCHEMA_URL": 10,
		"TRACE_FIELD_SCOPE_SCHEMA_URL":    11,
		"TRACE_FIELD_SCOPE_NAME":          12,
		"TRACE_FIELD_SCOPE_VERSION":       13,
	}
)

func (x TraceField) Enum() *TraceField {
	p := new(TraceField)
	*p = x
	return p
}

func (x TraceField) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TraceField) Descriptor() protoreflect.EnumDescriptor {
	return file_tero_policy_v1_trace_proto_enumTypes[0].Descriptor()
}

func (TraceField) Type() protoreflect.EnumType {
	return &file_tero_policy_v1_trace_proto_enumTypes[0]
}

func (x TraceField) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TraceField.Descriptor instead.
func (TraceField) EnumDescriptor() ([]byte, []int) {
	return file_tero_policy_v1_trace_proto_rawDescGZIP(), []int{0}
}

// SpanKind identifies the type of span for matching.
// Mirrors opentelemetry.proto.trace.v1.Span.SpanKind.
type SpanKind int32

const (
	SpanKind_SPAN_KIND_UNSPECIFIED SpanKind = 0
	SpanKind_SPAN_KIND_INTERNAL    SpanKind = 1
	SpanKind_SPAN_KIND_SERVER      SpanKind = 2
	SpanKind_SPAN_KIND_CLIENT      SpanKind = 3
	SpanKind_SPAN_KIND_PRODUCER    SpanKind = 4
	SpanKind_SPAN_KIND_CONSUMER    SpanKind = 5
)

// Enum value maps for SpanKind.
var (
	SpanKind_name = map[int32]string{
		0: "SPAN_KIND_UNSPECIFIED",
		1: "SPAN_KIND_INTERNAL",
		2: "SPAN_KIND_SERVER",
		3: "SPAN_KIND_CLIENT",
		4: "SPAN_KIND_PRODUCER",
		5: "SPAN_KIND_CONSUMER",
	}
	SpanKind_value = map[string]int32{
		"SPAN_KIND_UNSPECIFIED": 0,
		"SPAN_KIND_INTERNAL":    1,
		"SPAN_KIND_SERVER":      2,
		"SPAN_KIND_CLIENT":      3,
		"SPAN_KIND_PRODUCER":    4,
		"SPAN_KIND_CONSUMER":    5,
	}
)

func (x SpanKind) Enum() *SpanKind {
	p := new(SpanKind)
	*p = x
	return p
}

func (x SpanKind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SpanKind) Descriptor() protoreflect.EnumDescriptor {
	return file_tero_policy_v1_trace_proto_enumTypes[1].Descriptor()
}

func (SpanKind) Type() protoreflect.EnumType {
	return &file_tero_policy_v1_trace_proto_enumTypes[1]
}

func (x SpanKind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SpanKind.Descriptor instead.
func (SpanKind) EnumDescriptor() ([]byte, []int) {
	return file_tero_policy_v1_trace_proto_rawDescGZIP(), []int{1}
}

// SpanStatusCode identifies the span status for matching.
// Mirrors opentelemetry.proto.trace.v1.Status.StatusCode.
type SpanStatusCode int32

const (
	SpanStatusCode_SPAN_STATUS_CODE_UNSPECIFIED SpanStatusCode = 0
	SpanStatusCode_SPAN_STATUS_CODE_OK          SpanStatusCode = 1
	SpanStatusCode_SPAN_STATUS_CODE_ERROR       SpanStatusCode = 2
)

// Enum value maps for SpanStatusCode.
var (
	SpanStatusCode_name = map[int32]string{
		0: "SPAN_STATUS_CODE_UNSPECIFIED",
		1: "SPAN_STATUS_CODE_OK",
		2: "SPAN_STATUS_CODE_ERROR",
	}
	SpanStatusCode_value = map[string]int32{
		"SPAN_STATUS_CODE_UNSPECIFIED": 0,
		"SPAN_STATUS_CODE_OK":          1,
		"SPAN_STATUS_CODE_ERROR":       2,
	}
)

func (x SpanStatusCode) Enum() *SpanStatusCode {
	p := new(SpanStatusCode)
	*p = x
	return p
}

func (x SpanStatusCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SpanStatusCode) Descriptor() protoreflect.EnumDescriptor {
	return file_tero_policy_v1_trace_proto_enumTypes[2].Descriptor()
}

func (SpanStatusCode) Type() protoreflect.EnumType {
	return &file_tero_policy_v1_trace_proto_enumTypes[2]
}

func (x SpanStatusCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SpanStatusCode.Descriptor instead.
func (SpanStatusCode) EnumDescriptor() ([]byte, []int) {
	return file_tero_policy_v1_trace_proto_rawDescGZIP(), []int{2}
}

// SamplingMode determines how the sampling decision is made.
type SamplingMode int32

const (
	SamplingMode_SAMPLING_MODE_UNSPECIFIED SamplingMode = 0
	// hash_seed mode: Uses a hash of the trace ID combined with the hash_seed
	// to make deterministic sampling decisions. This is the default mode.
	// Suitable when you want consistent sampling across multiple collectors.
	SamplingMode_SAMPLING_MODE_HASH_SEED SamplingMode = 1
	// proportional mode: Respects existing sampling probability in tracestate.
	// Adjusts the effective probability to achieve the target percentage
	// relative to the incoming probability. For example, if incoming spans
	// are already sampled at 50% and target is 10%, this mode will sample
	// 20% of incoming spans to achieve 10% overall.
	SamplingMode_SAMPLING_MODE_PROPORTIONAL SamplingMode = 2
	// equalizing mode: Attempts to achieve the target percentage by preferentially
	// sampling spans that have been sampled at higher rates. This helps balance
	// the sampling across different sources while respecting existing thresholds.
	SamplingMode_SAMPLING_MODE_EQUALIZING SamplingMode = 3
)

// Enum value maps for SamplingMode.
var (
	SamplingMode_name = map[int32]string{
		0: "SAMPLING_MODE_UNSPECIFIED",
		1: "SAMPLING_MODE_HASH_SEED",
		2: "SAMPLING_MODE_PROPORTIONAL",
		3: "SAMPLING_MODE_EQUALIZING",
	}
	SamplingMode_value = map[string]int32{
		"SAMPLING_MODE_UNSPECIFIED":  0,
		"SAMPLING_MODE_HASH_SEED":    1,
		"SAMPLING_MODE_PROPORTIONAL": 2,
		"SAMPLING_MODE_EQUALIZING":   3,
	}
)

func (x SamplingMode) Enum() *SamplingMode {
	p := new(SamplingMode)
	*p = x
	return p
}

func (x SamplingMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SamplingMode) Descriptor() protoreflect.EnumDescriptor {
	return file_tero_policy_v1_trace_proto_enumTypes[3].Descriptor()
}

func (SamplingMode) Type() protoreflect.EnumType {
	return &file_tero_policy_v1_trace_proto_enumTypes[3]
}

func (x SamplingMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SamplingMode.Descriptor instead.
func (SamplingMode) EnumDescriptor() ([]byte, []int) {
	return file_tero_policy_v1_trace_proto_rawDescGZIP(), []int{3}
}

// TraceTarget defines matching and sampling actions for traces/spans.
type TraceTarget struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matchers to identify which spans this policy applies to (AND logic)
	Match []*TraceMatcher `protobuf:"bytes,1,rep,name=match,proto3" json:"match,omitempty"`
	// The keep field controls whether matching spans are sampled.
	// For traces, this uses probabilistic sampling with tracestate support.
	Keep          *TraceSamplingConfig `protobuf:"bytes,2,opt,name=keep,proto3" json:"keep,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TraceTarget) Reset() {
	*x = TraceTarget{}
	mi := &file_tero_policy_v1_trace_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TraceTarget) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TraceTarget) ProtoMessage() {}

func (x *TraceTarget) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_trace_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TraceTarget.ProtoReflect.Descriptor instead.
func (*TraceTarget) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_trace_proto_rawDescGZIP(), []int{0}
}

func (x *TraceTarget) GetMatch() []*TraceMatcher {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *TraceTarget) GetKeep() *TraceSamplingConfig {
	if x != nil {
		return x.Keep
	}
	return nil
}

// TraceMatcher provides a way to match against trace/span telemetry data using known fields.
//
// IMPORTANT CONSTRAINTS:
//   - Multiple matchers are ANDed together: all matchers must match for the
//     overall match to succeed.
//   - The list of matchers should uniquely identify a specific pattern of telemetry
//     for that policy. Matchers should NOT be used as a catch-all; they should be
//     specific enough to target the intended telemetry precisely.
//
// All regex fields use RE2 syntax for consistency across implementations.
type TraceMatcher struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// FIELD SELECTION
	// The field to match against. Exactly one must be set.
	//
	// Types that are valid to be assigned to Field:
	//
	//	*TraceMatcher_TraceField
	//	*TraceMatcher_SpanAttribute
	//	*TraceMatcher_ResourceAttribute
	//	*TraceMatcher_ScopeAttribute
	//	*TraceMatcher_SpanKind
	//	*TraceMatcher_SpanStatus
	//	*TraceMatcher_EventName
	//	*TraceMatcher_EventAttribute
	//	*TraceMatcher_LinkTraceId
	Field isTraceMatcher_Field `protobuf_oneof:"field"`
	// Match type. Exactly one must be set.
	// Note: For span_kind and span_status fields, only exists is valid (equality is implicit).
	//
	// Types that are valid to be assigned to Match:
	//
	//	*TraceMatcher_Exact
	//	*TraceMatcher_Regex
	//	*TraceMatcher_Exists
	//	*TraceMatcher_StartsWith
	//	*TraceMatcher_EndsWith
	//	*TraceMatcher_Contains
	Match isTraceMatcher_Match `protobuf_oneof:"match"`
	// If true, inverts the match result
	Negate bool `protobuf:"varint,20,opt,name=negate,proto3" json:"negate,omitempty"`
	// If true, applies case-insensitive matching to all match types
	CaseInsensitive bool `protobuf:"varint,21,opt,name=case_insensitive,json=caseInsensitive,proto3" json:"case_insensitive,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TraceMatcher) Reset() {
	*x = TraceMatcher{}
	mi := &file_tero_policy_v1_trace_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TraceMatcher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TraceMatcher) ProtoMessage() {}

func (x *TraceMatcher) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_trace_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TraceMatcher.ProtoReflect.Descriptor instead.
func (*TraceMatcher) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_trace_proto_rawDescGZIP(), []int{1}
}

func (x *TraceMatcher) GetField() isTraceMatcher_Field {
	if x != nil {
		return x.Field
	}
	return nil
}

func (x *TraceMatcher) GetTraceField() TraceField {
	if x != nil {
		if x, ok := x.Field.(*TraceMatcher_TraceField); ok {
			return x.TraceField
		}
	}
	return TraceField_TRACE_FIELD_UNSPECIFIED
}

func (x *TraceMatcher) GetSpanAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*TraceMatcher_SpanAttribute); ok {
			return x.SpanAttribute
		}
	}
	return nil
}

func (x *TraceMatcher) GetResourceAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*TraceMatcher_ResourceAttribute); ok {
			return x.ResourceAttribute
		}
	}
	return nil
}

func (x *TraceMatcher) GetScopeAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*TraceMatcher_ScopeAttribute); ok {
			return x.ScopeAttribute
		}
	}
	return nil
}

func (x *TraceMatcher) GetSpanKind() SpanKind {
	if x != nil {
		if x, ok := x.Field.(*TraceMatcher_SpanKind); ok {
			return x.SpanKind
		}
	}
	return SpanKind_SPAN_KIND_UNSPECIFIED
}

func (x *TraceMatcher) GetSpanStatus() SpanStatusCode {
	if x != nil {
		if x, ok := x.Field.(*TraceMatcher_SpanStatus); ok {
			return x.SpanStatus
		}
	}
	return SpanStatusCode_SPAN_STATUS_CODE_UNSPECIFIED
}

func (x *TraceMatcher) GetEventName() string {
	if x != nil {
		if x, ok := x.Field.(*TraceMatcher_EventName); ok {
			return x.EventName
		}
	}
	return ""
}

func (x *TraceMatcher) GetEventAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*TraceMatcher_EventAttribute); ok {
			return x.EventAttribute
		}
	}
	return nil
}

func (x *TraceMatcher) GetLinkTraceId() string {
	if x != nil {
		if x, ok := x.Field.(*TraceMatcher_LinkTraceId); ok {
			return x.LinkTraceId
		}
	}
	return ""
}

func (x *TraceMatcher) GetMatch() isTraceMatcher_Match {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *TraceMatcher) GetExact() string {
	if x != nil {
		if x, ok := x.Match.(*TraceMatcher_Exact); ok {
			return x.Exact
		}
	}
	return ""
}

func (x *TraceMatcher) GetRegex() string {
	if x != nil {
		if x, ok := x.Match.(*TraceMatcher_Regex); ok {
			return x.Regex
		}
	}
	return ""
}

func (x *TraceMatcher) GetExists() bool {
	if x != nil {
		if x, ok := x.Match.(*TraceMatcher_Exists); ok {
			return x.Exists
		}
	}
	return false
}

func (x *TraceMatcher) GetStartsWith() string {
	if x != nil {
		if x, ok := x.Match.(*TraceMatcher_StartsWith); ok {
			return x.StartsWith
		}
	}
	return ""
}

func (x *TraceMatcher) GetEndsWith() string {
	if x != nil {
		if x, ok := x.Match.(*TraceMatcher_EndsWith); ok {
			return x.EndsWith
		}
	}
	return ""
}

func (x *TraceMatcher) GetContains() string {
	if x != nil {
		if x, ok := x.Match.(*TraceMatcher_Contains); ok {
			return x.Contains
		}
	}
	return ""
}

func (x *TraceMatcher) GetNegate() bool {
	if x != nil {
		return x.Negate
	}
	return false
}

func (x *TraceMatcher) GetCaseInsensitive() bool {
	if x != nil {
		return x.CaseInsensitive
	}
	return false
}

type isTraceMatcher_Field interface {
	isTraceMatcher_Field()
}

type TraceMatcher_TraceField struct {
	// Simple fields (name, trace_id, span_id, etc.)
	TraceField TraceField `protobuf:"varint,1,opt,name=trace_field,json=traceField,proto3,enum=tero.policy.v1.TraceField,oneof"`
}

type TraceMatcher_SpanAttribute struct {
	// Span attribute by key or path
	SpanAttribute *AttributePath `protobuf:"bytes,2,opt,name=span_attribute,json=spanAttribute,proto3,oneof"`
}

type TraceMatcher_ResourceAttribute struct {
	// Resource attribute by key or path
	ResourceAttribute *AttributePath `protobuf:"bytes,3,opt,name=resource_attribute,json=resourceAttribute,proto3,oneof"`
}

type TraceMatcher_ScopeAttribute struct {
	// Scope attribute by key or path
	ScopeAttribute *AttributePath `protobuf:"bytes,4,opt,name=scope_attribute,json=scopeAttribute,proto3,oneof"`
}

type TraceMatcher_SpanKind struct {
	// Span kind matcher
	SpanKind SpanKind `protobuf:"varint,5,opt,name=span_kind,json=spanKind,proto3,enum=tero.policy.v1.SpanKind,oneof"`
}

type TraceMatcher_SpanStatus struct {
	// Span status code matcher
	SpanStatus SpanStatusCode `protobuf:"varint,6,opt,name=span_status,json=spanStatus,proto3,enum=tero.policy.v1.SpanStatusCode,oneof"`
}

type TraceMatcher_EventName struct {
	// Event name matcher (matches if span contains an event with this name)
	EventName string `protobuf:"bytes,7,opt,name=event_name,json=eventName,proto3,oneof"`
}

type TraceMatcher_EventAttribute struct {
	// Event attribute matcher (matches if span contains an event with this attribute)
	EventAttribute *AttributePath `protobuf:"bytes,8,opt,name=event_attribute,json=eventAttribute,proto3,oneof"`
}

type TraceMatcher_LinkTraceId struct {
	// Link trace ID matcher (matches if span has a link to this trace)
	LinkTraceId string `protobuf:"bytes,9,opt,name=link_trace_id,json=linkTraceId,proto3,oneof"`
}

func (*TraceMatcher_TraceField) isTraceMatcher_Field() {}

func (*TraceMatcher_SpanAttribute) isTraceMatcher_Field() {}

func (*TraceMatcher_ResourceAttribute) isTraceMatcher_Field() {}

func (*TraceMatcher_ScopeAttribute) isTraceMatcher_Field() {}

func (*TraceMatcher_SpanKind) isTraceMatcher_Field() {}

func (*TraceMatcher_SpanStatus) isTraceMatcher_Field() {}

func (*TraceMatcher_EventName) isTraceMatcher_Field() {}

func (*TraceMatcher_EventAttribute) isTraceMatcher_Field() {}

func (*TraceMatcher_LinkTraceId) isTraceMatcher_Field() {}

type isTraceMatcher_Match interface {
	isTraceMatcher_Match()
}

type TraceMatcher_Exact struct {
	// Exact string match
	Exact string `protobuf:"bytes,10,opt,name=exact,proto3,oneof"`
}

type TraceMatcher_Regex struct {
	// Regular expression match
	Regex string `protobuf:"bytes,11,opt,name=regex,proto3,oneof"`
}

type TraceMatcher_Exists struct {
	// Field existence check
	Exists bool `protobuf:"varint,12,opt,name=exists,proto3,oneof"`
}

type TraceMatcher_StartsWith struct {
	// Literal prefix match
	StartsWith string `protobuf:"bytes,13,opt,name=starts_with,json=startsWith,proto3,oneof"`
}

type TraceMatcher_EndsWith struct {
	// Literal suffix match
	EndsWith string `protobuf:"bytes,14,opt,name=ends_with,json=endsWith,proto3,oneof"`
}

type TraceMatcher_Contains struct {
	// Literal substring match
	Contains string `protobuf:"bytes,15,opt,name=contains,proto3,oneof"`
}

func (*TraceMatcher_Exact) isTraceMatcher_Match() {}

func (*TraceMatcher_Regex) isTraceMatcher_Match() {}

func (*TraceMatcher_Exists) isTraceMatcher_Match() {}

func (*TraceMatcher_StartsWith) isTraceMatcher_Match() {}

func (*TraceMatcher_EndsWith) isTraceMatcher_Match() {}

func (*TraceMatcher_Contains) isTraceMatcher_Match() {}

// TraceSamplingConfig configures probabilistic sampling for traces.
//
// This configuration follows the OpenTelemetry probability sampling specification:
// https://opentelemetry.io/docs/specs/otel/trace/tracestate-probability-sampling/
//
// Implementations MUST follow tracestate standards to allow multi-stage sampling:
// https://opentelemetry.io/docs/specs/otel/trace/tracestate-handling/#sampling-threshold-value-th
//
// The sampling decision is based on comparing a 56-bit randomness value (R) against
// a rejection threshold (T). If R >= T, the span is kept; otherwise it is dropped.
// The threshold is derived from the configured percentage:
//
//	T = (1 - percentage/100) * 2^56
type TraceSamplingConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Percentage at which items are sampled (0-100).
	// >= 100 samples all items, 0 rejects all items.
	// This is a 32-bit floating point value for precision.
	Percentage float32 `protobuf:"fixed32,1,opt,name=percentage,proto3" json:"percentage,omitempty"`
	// Sampling mode determines how the sampling decision is made.
	// Optional. Default is SAMPLING_MODE_HASH_SEED.
	Mode *SamplingMode `protobuf:"varint,2,opt,name=mode,proto3,enum=tero.policy.v1.SamplingMode,oneof" json:"mode,omitempty"`
	// Determines the number of hexadecimal digits used to encode the sampling threshold
	// in the tracestate. Permitted values are 1-14.
	// Optional. Default is 4.
	// Higher precision allows finer-grained sampling probabilities.
	// The threshold is encoded with trailing zeros removed.
	SamplingPrecision *uint32 `protobuf:"varint,3,opt,name=sampling_precision,json=samplingPrecision,proto3,oneof" json:"sampling_precision,omitempty"`
	// An integer used to compute the hash algorithm.
	// All collectors for a given tier (e.g., behind the same load balancer)
	// should have the same hash_seed to ensure consistent sampling decisions.
	// Optional. Default is 0.
	HashSeed *uint32 `protobuf:"varint,4,opt,name=hash_seed,json=hashSeed,proto3,oneof" json:"hash_seed,omitempty"`
	// Determines behavior when sampling errors occur.
	// When true (default), items with errors are rejected (fail closed).
	// When false, items with errors are accepted (fail open).
	// Optional. Default is true.
	FailClosed    *bool `protobuf:"varint,5,opt,name=fail_closed,json=failClosed,proto3,oneof" json:"fail_closed,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TraceSamplingConfig) Reset() {
	*x = TraceSamplingConfig{}
	mi := &file_tero_policy_v1_trace_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TraceSamplingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TraceSamplingConfig) ProtoMessage() {}

func (x *TraceSamplingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_trace_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TraceSamplingConfig.ProtoReflect.Descriptor instead.
func (*TraceSamplingConfig) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_trace_proto_rawDescGZIP(), []int{2}
}

func (x *TraceSamplingConfig) GetPercentage() float32 {
	if x != nil {
		return x.Percentage
	}
	return 0
}

func (x *TraceSamplingConfig) GetMode() SamplingMode {
	if x != nil && x.Mode != nil {
		return *x.Mode
	}
	return SamplingMode_SAMPLING_MODE_UNSPECIFIED
}

func (x *TraceSamplingConfig) GetSamplingPrecision() uint32 {
	if x != nil && x.SamplingPrecision != nil {
		return *x.SamplingPrecision
	}
	return 0
}

func (x *TraceSamplingConfig) GetHashSeed() uint32 {
	if x != nil && x.HashSeed != nil {
		return *x.HashSeed
	}
	return 0
}

func (x *TraceSamplingConfig) GetFailClosed() bool {
	if x != nil && x.FailClosed != nil {
		return *x.FailClosed
	}
	return false
}

var File_tero_policy_v1_trace_proto protoreflect.FileDescriptor

const file_tero_policy_v1_trace_proto_rawDesc = "" +
	"\n" +
	"\x1atero/policy/v1/trace.proto\x12\x0etero.policy.v1\x1a\x1btero/policy/v1/shared.proto\"z\n" +
	"\vTraceTarget\x122\n" +
	"\x05match\x18\x01 \x03(\v2\x1c.tero.policy.v1.TraceMatcherR\x05match\x127\n" +
	"\x04keep\x18\x02 \x01(\v2#.tero.policy.v1.TraceSamplingConfigR\x04keep\"\xbb\x06\n" +
	"\fTraceMatcher\x12=\n" +
	"\vtrace_field\x18\x01 \x01(\x0e2\x1a.tero.policy.v1.TraceFieldH\x00R\n" +
	"traceField\x12F\n" +
	"\x0espan_attribute\x18\x02 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\rspanAttribute\x12N\n" +
	"\x12resource_attribute\x18\x03 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x11resourceAttribute\x12H\n" +
	"\x0fscope_attribute\x18\x04 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x0escopeAttribute\x127\n" +
	"\tspan_kind\x18\x05 \x01(\x0e2\x18.tero.policy.v1.SpanKindH\x00R\bspanKind\x12A\n" +
	"\vspan_status\x18\x06 \x01(\x0e2\x1e.tero.policy.v1.SpanStatusCodeH\x00R\n" +
	"spanStatus\x12\x1f\n" +
	"\n" +
	"event_name\x18\a \x01(\tH\x00R\teventName\x12H\n" +
	"\x0fevent_attribute\x18\b \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x0eeventAttribute\x12$\n" +
	"\rlink_trace_id\x18\t \x01(\tH\x00R\vlinkTraceId\x12\x16\n" +
	"\x05exact\x18\n" +
	" \x01(\tH\x01R\x05exact\x12\x16\n" +
	"\x05regex\x18\v \x01(\tH\x01R\x05regex\x12\x18\n" +
	"\x06exists\x18\f \x01(\bH\x01R\x06exists\x12!\n" +
	"\vstarts_with\x18\r \x01(\tH\x01R\n" +
	"startsWith\x12\x1d\n" +
	"\tends_with\x18\x0e \x01(\tH\x01R\bendsWith\x12\x1c\n" +
	"\bcontains\x18\x0f \x01(\tH\x01R\bcontains\x12\x16\n" +
	"\x06negate\x18\x14 \x01(\bR\x06negate\x12)\n" +
	"\x10case_insensitive\x18\x15 \x01(\bR\x0fcaseInsensitiveB\a\n" +
	"\x05fieldB\a\n" +
	"\x05match\"\xa6\x02\n" +
	"\x13TraceSamplingConfig\x12\x1e\n" +
	"\n" +
	"percentage\x18\x01 \x01(\x02R\n" +
	"percentage\x125\n" +
	"\x04mode\x18\x02 \x01(\x0e2\x1c.tero.policy.v1.SamplingModeH\x00R\x04mode\x88\x01\x01\x122\n" +
	"\x12sampling_precision\x18\x03 \x01(\rH\x01R\x11samplingPrecision\x88\x01\x01\x12 \n" +
	"\thash_seed\x18\x04 \x01(\rH\x02R\bhashSeed\x88\x01\x01\x12$\n" +
	"\vfail_closed\x18\x05 \x01(\bH\x03R\n" +
	"failClosed\x88\x01\x01B\a\n" +
	"\x05_modeB\x15\n" +
	"\x13_sampling_precisionB\f\n" +
	"\n" +
	"_hash_seedB\x0e\n" +
	"\f_fail_closed*\xb1\x02\n" +
	"\n" +
	"TraceField\x12\x1b\n" +
	"\x17TRACE_FIELD_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10TRACE_FIELD_NAME\x10\x01\x12\x18\n" +
	"\x14TRACE_FIELD_TRACE_ID\x10\x02\x12\x17\n" +
	"\x13TRACE_FIELD_SPAN_ID\x10\x03\x12\x1e\n" +
	"\x1aTRACE_FIELD_PARENT_SPAN_ID\x10\x04\x12\x1b\n" +
	"\x17TRACE_FIELD_TRACE_STATE\x10\x05\x12#\n" +
	"\x1fTRACE_FIELD_RESOURCE_SCHEMA_URL\x10\n" +
	"\x12 \n" +
	"\x1cTRACE_FIELD_SCOPE_SCHEMA_URL\x10\v\x12\x1a\n" +
	"\x16TRACE_FIELD_SCOPE_NAME\x10\f\x12\x1d\n" +
	"\x19TRACE_FIELD_SCOPE_VERSION\x10\r*\x99\x01\n" +
	"\bSpanKind\x12\x19\n" +
	"\x15SPAN_KIND_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12SPAN_KIND_INTERNAL\x10\x01\x12\x14\n" +
	"\x10SPAN_KIND_SERVER\x10\x02\x12\x14\n" +
	"\x10SPAN_KIND_CLIENT\x10\x03\x12\x16\n" +
	"\x12SPAN_KIND_PRODUCER\x10\x04\x12\x16\n" +
	"\x12SPAN_KIND_CONSUMER\x10\x05*g\n" +
	"\x0eSpanStatusCode\x12 \n" +
	"\x1cSPAN_STATUS_CODE_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13SPAN_STATUS_CODE_OK\x10\x01\x12\x1a\n" +
	"\x16SPAN_STATUS_CODE_ERROR\x10\x02*\x88\x01\n" +
	"\fSamplingMode\x12\x1d\n" +
	"\x19SAMPLING_MODE_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17SAMPLING_MODE_HASH_SEED\x10\x01\x12\x1e\n" +
	"\x1aSAMPLING_MODE_PROPORTIONAL\x10\x02\x12\x1c\n" +
	"\x18SAMPLING_MODE_EQUALIZING\x10\x03B1Z/github.com/usetero/policy/gen/go/tero/policy/v1b\x06proto3"

var (
	file_tero_policy_v1_trace_proto_rawDescOnce sync.Once
	file_tero_policy_v1_trace_proto_rawDescData []byte
)

func file_tero_policy_v1_trace_proto_rawDescGZIP() []byte {
	file_tero_policy_v1_trace_proto_rawDescOnce.Do(func() {
		file_tero_policy_v1_trace_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tero_policy_v1_trace_proto_rawDesc), len(file_tero_policy_v1_trace_proto_rawDesc)))
	})
	return file_tero_policy_v1_trace_proto_rawDescData
}

var file_tero_policy_v1_trace_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_tero_policy_v1_trace_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_tero_policy_v1_trace_proto_goTypes = []any{
	(TraceField)(0),             // 0: tero.policy.v1.TraceField
	(SpanKind)(0),               // 1: tero.policy.v1.SpanKind
	(SpanStatusCode)(0),         // 2: tero.policy.v1.SpanStatusCode
	(SamplingMode)(0),           // 3: tero.policy.v1.SamplingMode
	(*TraceTarget)(nil),         // 4: tero.policy.v1.TraceTarget
	(*TraceMatcher)(nil),        // 5: tero.policy.v1.TraceMatcher
	(*TraceSamplingConfig)(nil), // 6: tero.policy.v1.TraceSamplingConfig
	(*AttributePath)(nil),       // 7: tero.policy.v1.AttributePath
}
var file_tero_policy_v1_trace_proto_depIdxs = []int32{
	5,  // 0: tero.policy.v1.TraceTarget.match:type_name -> tero.policy.v1.TraceMatcher
	6,  // 1: tero.policy.v1.TraceTarget.keep:type_name -> tero.policy.v1.TraceSamplingConfig
	0,  // 2: tero.policy.v1.TraceMatcher.trace_field:type_name -> tero.policy.v1.TraceField
	7,  // 3: tero.policy.v1.TraceMatcher.span_attribute:type_name -> tero.policy.v1.AttributePath
	7,  // 4: tero.policy.v1.TraceMatcher.resource_attribute:type_name -> tero.policy.v1.AttributePath
	7,  // 5: tero.policy.v1.TraceMatcher.scope_attribute:type_name -> tero.policy.v1.AttributePath
	1,  // 6: tero.policy.v1.TraceMatcher.span_kind:type_name -> tero.policy.v1.SpanKind
	2,  // 7: tero.policy.v1.TraceMatcher.span_status:type_name -> tero.policy.v1.SpanStatusCode
	7,  // 8: tero.policy.v1.TraceMatcher.event_attribute:type_name -> tero.policy.v1.AttributePath
	3,  // 9: tero.policy.v1.TraceSamplingConfig.mode:type_name -> tero.policy.v1.SamplingMode
	10, // [10:10] is the sub-list for method output_type
	10, // [10:10] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_tero_policy_v1_trace_proto_init() }
func file_tero_policy_v1_trace_proto_init() {
	if File_tero_policy_v1_trace_proto != nil {
		return
	}
	file_tero_policy_v1_shared_proto_init()
	file_tero_policy_v1_trace_proto_msgTypes[1].OneofWrappers = []any{
		(*TraceMatcher_TraceField)(nil),
		(*TraceMatcher_SpanAttribute)(nil),
		(*TraceMatcher_ResourceAttribute)(nil),
		(*TraceMatcher_ScopeAttribute)(nil),
		(*TraceMatcher_SpanKind)(nil),
		(*TraceMatcher_SpanStatus)(nil),
		(*TraceMatcher_EventName)(nil),
		(*TraceMatcher_EventAttribute)(nil),
		(*TraceMatcher_LinkTraceId)(nil),
		(*TraceMatcher_Exact)(nil),
		(*TraceMatcher_Regex)(nil),
		(*TraceMatcher_Exists)(nil),
		(*TraceMatcher_StartsWith)(nil),
		(*TraceMatcher_EndsWith)(nil),
		(*TraceMatcher_Contains)(nil),
	}
	file_tero_policy_v1_trace_proto_msgTypes[2].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tero_policy_v1_trace_proto_rawDesc), len(file_tero_policy_v1_trace_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_tero_policy_v1_trace_proto_goTypes,
		DependencyIndexes: file_tero_policy_v1_trace_proto_depIdxs,
		EnumInfos:         file_tero_policy_v1_trace_proto_enumTypes,
		MessageInfos:      file_tero_policy_v1_trace_proto_msgTypes,
	}.Build()
	File_tero_policy_v1_trace_proto = out.File
	file_tero_policy_v1_trace_proto_goTypes = nil
	file_tero_policy_v1_trace_proto_depIdxs = nil
}
