// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: tero/policy/v1/policy.proto

package v1

import (
	v1 "go.opentelemetry.io/proto/otlp/common/v1"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// PolicyStage identifies the execution stage for a policy.
type PolicyStage int32

const (
	PolicyStage_POLICY_STAGE_UNSPECIFIED    PolicyStage = 0
	PolicyStage_POLICY_STAGE_LOG_FILTER     PolicyStage = 1 // Log filtering stage (keep/drop decisions)
	PolicyStage_POLICY_STAGE_LOG_TRANSFORM  PolicyStage = 2 // Log transformation stage (field modifications)
	PolicyStage_POLICY_STAGE_METRIC_FILTER  PolicyStage = 3 // Metric filtering stage (keep/drop decisions)
	PolicyStage_POLICY_STAGE_TRACE_SAMPLING PolicyStage = 4 // Trace probabilistic sampling stage
)

// Enum value maps for PolicyStage.
var (
	PolicyStage_name = map[int32]string{
		0: "POLICY_STAGE_UNSPECIFIED",
		1: "POLICY_STAGE_LOG_FILTER",
		2: "POLICY_STAGE_LOG_TRANSFORM",
		3: "POLICY_STAGE_METRIC_FILTER",
		4: "POLICY_STAGE_TRACE_SAMPLING",
	}
	PolicyStage_value = map[string]int32{
		"POLICY_STAGE_UNSPECIFIED":    0,
		"POLICY_STAGE_LOG_FILTER":     1,
		"POLICY_STAGE_LOG_TRANSFORM":  2,
		"POLICY_STAGE_METRIC_FILTER":  3,
		"POLICY_STAGE_TRACE_SAMPLING": 4,
	}
)

func (x PolicyStage) Enum() *PolicyStage {
	p := new(PolicyStage)
	*p = x
	return p
}

func (x PolicyStage) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PolicyStage) Descriptor() protoreflect.EnumDescriptor {
	return file_tero_policy_v1_policy_proto_enumTypes[0].Descriptor()
}

func (PolicyStage) Type() protoreflect.EnumType {
	return &file_tero_policy_v1_policy_proto_enumTypes[0]
}

func (x PolicyStage) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PolicyStage.Descriptor instead.
func (PolicyStage) EnumDescriptor() ([]byte, []int) {
	return file_tero_policy_v1_policy_proto_rawDescGZIP(), []int{0}
}

type SyncType int32

const (
	SyncType_SYNC_TYPE_UNSPECIFIED SyncType = 0
	SyncType_SYNC_TYPE_FULL        SyncType = 1
)

// Enum value maps for SyncType.
var (
	SyncType_name = map[int32]string{
		0: "SYNC_TYPE_UNSPECIFIED",
		1: "SYNC_TYPE_FULL",
	}
	SyncType_value = map[string]int32{
		"SYNC_TYPE_UNSPECIFIED": 0,
		"SYNC_TYPE_FULL":        1,
	}
)

func (x SyncType) Enum() *SyncType {
	p := new(SyncType)
	*p = x
	return p
}

func (x SyncType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SyncType) Descriptor() protoreflect.EnumDescriptor {
	return file_tero_policy_v1_policy_proto_enumTypes[1].Descriptor()
}

func (SyncType) Type() protoreflect.EnumType {
	return &file_tero_policy_v1_policy_proto_enumTypes[1]
}

func (x SyncType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SyncType.Descriptor instead.
func (SyncType) EnumDescriptor() ([]byte, []int) {
	return file_tero_policy_v1_policy_proto_rawDescGZIP(), []int{1}
}

// Policy represents a complete telemetry policy definition.
// Policies are designed to be:
// - Implementation Agnostic: Works in SDK, Collector, or any component
// - Standalone: No need to understand pipeline configuration
// - Dynamic: Can be updated post-instantiation
// - Idempotent: Safe to apply to multiple components
// - Fail-Open: Does not interfere with telemetry on failure
type Policy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this policy
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human-readable name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Optional description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Whether this policy is enabled
	Enabled bool `protobuf:"varint,4,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Timestamp when this policy was created (Unix epoch nanoseconds)
	CreatedAtUnixNano uint64 `protobuf:"fixed64,5,opt,name=created_at_unix_nano,json=createdAtUnixNano,proto3" json:"created_at_unix_nano,omitempty"`
	// Timestamp when this policy was last modified (Unix epoch nanoseconds)
	ModifiedAtUnixNano uint64 `protobuf:"fixed64,6,opt,name=modified_at_unix_nano,json=modifiedAtUnixNano,proto3" json:"modified_at_unix_nano,omitempty"`
	// Labels for metadata and routing
	Labels []*v1.KeyValue `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty"`
	// Target configuration. Exactly one must be set.
	//
	// Types that are valid to be assigned to Target:
	//
	//	*Policy_Log
	//	*Policy_Metric
	//	*Policy_Trace
	Target        isPolicy_Target `protobuf_oneof:"target"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Policy) Reset() {
	*x = Policy{}
	mi := &file_tero_policy_v1_policy_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Policy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Policy) ProtoMessage() {}

func (x *Policy) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_policy_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Policy.ProtoReflect.Descriptor instead.
func (*Policy) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_policy_proto_rawDescGZIP(), []int{0}
}

func (x *Policy) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Policy) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Policy) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Policy) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *Policy) GetCreatedAtUnixNano() uint64 {
	if x != nil {
		return x.CreatedAtUnixNano
	}
	return 0
}

func (x *Policy) GetModifiedAtUnixNano() uint64 {
	if x != nil {
		return x.ModifiedAtUnixNano
	}
	return 0
}

func (x *Policy) GetLabels() []*v1.KeyValue {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Policy) GetTarget() isPolicy_Target {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *Policy) GetLog() *LogTarget {
	if x != nil {
		if x, ok := x.Target.(*Policy_Log); ok {
			return x.Log
		}
	}
	return nil
}

func (x *Policy) GetMetric() *MetricTarget {
	if x != nil {
		if x, ok := x.Target.(*Policy_Metric); ok {
			return x.Metric
		}
	}
	return nil
}

func (x *Policy) GetTrace() *TraceTarget {
	if x != nil {
		if x, ok := x.Target.(*Policy_Trace); ok {
			return x.Trace
		}
	}
	return nil
}

type isPolicy_Target interface {
	isPolicy_Target()
}

type Policy_Log struct {
	Log *LogTarget `protobuf:"bytes,10,opt,name=log,proto3,oneof"`
}

type Policy_Metric struct {
	Metric *MetricTarget `protobuf:"bytes,11,opt,name=metric,proto3,oneof"`
}

type Policy_Trace struct {
	Trace *TraceTarget `protobuf:"bytes,12,opt,name=trace,proto3,oneof"`
}

func (*Policy_Log) isPolicy_Target() {}

func (*Policy_Metric) isPolicy_Target() {}

func (*Policy_Trace) isPolicy_Target() {}

// ClientMetadata contains information about the client requesting policies.
type ClientMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Policy stages this client supports
	SupportedPolicyStages []PolicyStage `protobuf:"varint,1,rep,packed,name=supported_policy_stages,json=supportedPolicyStages,proto3,enum=tero.policy.v1.PolicyStage" json:"supported_policy_stages,omitempty"`
	// Additional metadata labels
	Labels []*v1.KeyValue `protobuf:"bytes,2,rep,name=labels,proto3" json:"labels,omitempty"`
	// Resource attributes describing this client's identity
	// REQUIRED:
	// * service.instance.id
	// * service.name
	// * service.namespace
	// * service.version
	ResourceAttributes []*v1.KeyValue `protobuf:"bytes,3,rep,name=resource_attributes,json=resourceAttributes,proto3" json:"resource_attributes,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ClientMetadata) Reset() {
	*x = ClientMetadata{}
	mi := &file_tero_policy_v1_policy_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientMetadata) ProtoMessage() {}

func (x *ClientMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_policy_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientMetadata.ProtoReflect.Descriptor instead.
func (*ClientMetadata) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_policy_proto_rawDescGZIP(), []int{1}
}

func (x *ClientMetadata) GetSupportedPolicyStages() []PolicyStage {
	if x != nil {
		return x.SupportedPolicyStages
	}
	return nil
}

func (x *ClientMetadata) GetLabels() []*v1.KeyValue {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *ClientMetadata) GetResourceAttributes() []*v1.KeyValue {
	if x != nil {
		return x.ResourceAttributes
	}
	return nil
}

// TransformStageStatus reports hits and misses for a single transform stage.
type TransformStageStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of times this stage was applied.
	Hits int64 `protobuf:"varint,1,opt,name=hits,proto3" json:"hits,omitempty"`
	// Number of times this stage was evaluated but the field selected nothing.
	Misses        int64 `protobuf:"varint,2,opt,name=misses,proto3" json:"misses,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransformStageStatus) Reset() {
	*x = TransformStageStatus{}
	mi := &file_tero_policy_v1_policy_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransformStageStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransformStageStatus) ProtoMessage() {}

func (x *TransformStageStatus) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_policy_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransformStageStatus.ProtoReflect.Descriptor instead.
func (*TransformStageStatus) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_policy_proto_rawDescGZIP(), []int{2}
}

func (x *TransformStageStatus) GetHits() int64 {
	if x != nil {
		return x.Hits
	}
	return 0
}

func (x *TransformStageStatus) GetMisses() int64 {
	if x != nil {
		return x.Misses
	}
	return 0
}

// PolicySyncStatus reports the status of an individual policy during sync.
// Used to communicate policy execution metrics and errors back to the provider.
type PolicySyncStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The policy ID this status refers to.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Number of times this policy matched telemetry since the last sync.
	MatchHits int64 `protobuf:"varint,2,opt,name=match_hits,json=matchHits,proto3" json:"match_hits,omitempty"`
	// Number of times this policy was evaluated but did not match.
	MatchMisses int64 `protobuf:"varint,3,opt,name=match_misses,json=matchMisses,proto3" json:"match_misses,omitempty"`
	// Error messages encountered while applying this policy.
	Errors []string `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
	// Transform stage statistics
	Remove        *TransformStageStatus `protobuf:"bytes,10,opt,name=remove,proto3" json:"remove,omitempty"`
	Redact        *TransformStageStatus `protobuf:"bytes,11,opt,name=redact,proto3" json:"redact,omitempty"`
	Rename        *TransformStageStatus `protobuf:"bytes,12,opt,name=rename,proto3" json:"rename,omitempty"`
	Add           *TransformStageStatus `protobuf:"bytes,13,opt,name=add,proto3" json:"add,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PolicySyncStatus) Reset() {
	*x = PolicySyncStatus{}
	mi := &file_tero_policy_v1_policy_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PolicySyncStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PolicySyncStatus) ProtoMessage() {}

func (x *PolicySyncStatus) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_policy_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PolicySyncStatus.ProtoReflect.Descriptor instead.
func (*PolicySyncStatus) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_policy_proto_rawDescGZIP(), []int{3}
}

func (x *PolicySyncStatus) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *PolicySyncStatus) GetMatchHits() int64 {
	if x != nil {
		return x.MatchHits
	}
	return 0
}

func (x *PolicySyncStatus) GetMatchMisses() int64 {
	if x != nil {
		return x.MatchMisses
	}
	return 0
}

func (x *PolicySyncStatus) GetErrors() []string {
	if x != nil {
		return x.Errors
	}
	return nil
}

func (x *PolicySyncStatus) GetRemove() *TransformStageStatus {
	if x != nil {
		return x.Remove
	}
	return nil
}

func (x *PolicySyncStatus) GetRedact() *TransformStageStatus {
	if x != nil {
		return x.Redact
	}
	return nil
}

func (x *PolicySyncStatus) GetRename() *TransformStageStatus {
	if x != nil {
		return x.Rename
	}
	return nil
}

func (x *PolicySyncStatus) GetAdd() *TransformStageStatus {
	if x != nil {
		return x.Add
	}
	return nil
}

// SyncRequest is sent by clients to request policy updates.
type SyncRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Client identification and capabilities
	ClientMetadata *ClientMetadata `protobuf:"bytes,1,opt,name=client_metadata,json=clientMetadata,proto3" json:"client_metadata,omitempty"`
	// Request full sync (ignore policy_statuses)
	FullSync bool `protobuf:"varint,2,opt,name=full_sync,json=fullSync,proto3" json:"full_sync,omitempty"`
	// Last sync timestamp (Unix epoch nanoseconds)
	LastSyncTimestampUnixNano uint64 `protobuf:"fixed64,3,opt,name=last_sync_timestamp_unix_nano,json=lastSyncTimestampUnixNano,proto3" json:"last_sync_timestamp_unix_nano,omitempty"`
	// The hash of the policy list as last received by the client.
	LastSuccessfulHash string `protobuf:"bytes,4,opt,name=last_successful_hash,json=lastSuccessfulHash,proto3" json:"last_successful_hash,omitempty"`
	// Status of individual policies within this set.
	PolicyStatuses []*PolicySyncStatus `protobuf:"bytes,5,rep,name=policy_statuses,json=policyStatuses,proto3" json:"policy_statuses,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *SyncRequest) Reset() {
	*x = SyncRequest{}
	mi := &file_tero_policy_v1_policy_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncRequest) ProtoMessage() {}

func (x *SyncRequest) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_policy_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SyncRequest.ProtoReflect.Descriptor instead.
func (*SyncRequest) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_policy_proto_rawDescGZIP(), []int{4}
}

func (x *SyncRequest) GetClientMetadata() *ClientMetadata {
	if x != nil {
		return x.ClientMetadata
	}
	return nil
}

func (x *SyncRequest) GetFullSync() bool {
	if x != nil {
		return x.FullSync
	}
	return false
}

func (x *SyncRequest) GetLastSyncTimestampUnixNano() uint64 {
	if x != nil {
		return x.LastSyncTimestampUnixNano
	}
	return 0
}

func (x *SyncRequest) GetLastSuccessfulHash() string {
	if x != nil {
		return x.LastSuccessfulHash
	}
	return ""
}

func (x *SyncRequest) GetPolicyStatuses() []*PolicySyncStatus {
	if x != nil {
		return x.PolicyStatuses
	}
	return nil
}

// SyncResponse contains policy updates for the client.
type SyncResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The policies to sync
	Policies []*Policy `protobuf:"bytes,1,rep,name=policies,proto3" json:"policies,omitempty"`
	// Hash of the entire list of policies (for change detection)
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// Timestamp of this sync (Unix epoch nanoseconds)
	SyncTimestampUnixNano uint64 `protobuf:"fixed64,3,opt,name=sync_timestamp_unix_nano,json=syncTimestampUnixNano,proto3" json:"sync_timestamp_unix_nano,omitempty"`
	// Suggested interval before next sync (in seconds)
	RecommendedSyncIntervalSeconds uint32 `protobuf:"varint,4,opt,name=recommended_sync_interval_seconds,json=recommendedSyncIntervalSeconds,proto3" json:"recommended_sync_interval_seconds,omitempty"`
	// Whether this is a full replacement or incremental update
	SyncType SyncType `protobuf:"varint,5,opt,name=sync_type,json=syncType,proto3,enum=tero.policy.v1.SyncType" json:"sync_type,omitempty"`
	// Error message if sync failed
	ErrorMessage  string `protobuf:"bytes,6,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SyncResponse) Reset() {
	*x = SyncResponse{}
	mi := &file_tero_policy_v1_policy_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SyncResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SyncResponse) ProtoMessage() {}

func (x *SyncResponse) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_policy_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SyncResponse.ProtoReflect.Descriptor instead.
func (*SyncResponse) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_policy_proto_rawDescGZIP(), []int{5}
}

func (x *SyncResponse) GetPolicies() []*Policy {
	if x != nil {
		return x.Policies
	}
	return nil
}

func (x *SyncResponse) GetHash() string {
	if x != nil {
		return x.Hash
	}
	return ""
}

func (x *SyncResponse) GetSyncTimestampUnixNano() uint64 {
	if x != nil {
		return x.SyncTimestampUnixNano
	}
	return 0
}

func (x *SyncResponse) GetRecommendedSyncIntervalSeconds() uint32 {
	if x != nil {
		return x.RecommendedSyncIntervalSeconds
	}
	return 0
}

func (x *SyncResponse) GetSyncType() SyncType {
	if x != nil {
		return x.SyncType
	}
	return SyncType_SYNC_TYPE_UNSPECIFIED
}

func (x *SyncResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

var File_tero_policy_v1_policy_proto protoreflect.FileDescriptor

const file_tero_policy_v1_policy_proto_rawDesc = "" +
	"\n" +
	"\x1btero/policy/v1/policy.proto\x12\x0etero.policy.v1\x1a\x1cgoogle/api/annotations.proto\x1a*opentelemetry/proto/common/v1/common.proto\x1a\x18tero/policy/v1/log.proto\x1a\x1btero/policy/v1/metric.proto\x1a\x1atero/policy/v1/trace.proto\"\xb3\x03\n" +
	"\x06Policy\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x18\n" +
	"\aenabled\x18\x04 \x01(\bR\aenabled\x12/\n" +
	"\x14created_at_unix_nano\x18\x05 \x01(\x06R\x11createdAtUnixNano\x121\n" +
	"\x15modified_at_unix_nano\x18\x06 \x01(\x06R\x12modifiedAtUnixNano\x12?\n" +
	"\x06labels\x18\a \x03(\v2'.opentelemetry.proto.common.v1.KeyValueR\x06labels\x12-\n" +
	"\x03log\x18\n" +
	" \x01(\v2\x19.tero.policy.v1.LogTargetH\x00R\x03log\x126\n" +
	"\x06metric\x18\v \x01(\v2\x1c.tero.policy.v1.MetricTargetH\x00R\x06metric\x123\n" +
	"\x05trace\x18\f \x01(\v2\x1b.tero.policy.v1.TraceTargetH\x00R\x05traceB\b\n" +
	"\x06target\"\x80\x02\n" +
	"\x0eClientMetadata\x12S\n" +
	"\x17supported_policy_stages\x18\x01 \x03(\x0e2\x1b.tero.policy.v1.PolicyStageR\x15supportedPolicyStages\x12?\n" +
	"\x06labels\x18\x02 \x03(\v2'.opentelemetry.proto.common.v1.KeyValueR\x06labels\x12X\n" +
	"\x13resource_attributes\x18\x03 \x03(\v2'.opentelemetry.proto.common.v1.KeyValueR\x12resourceAttributes\"B\n" +
	"\x14TransformStageStatus\x12\x12\n" +
	"\x04hits\x18\x01 \x01(\x03R\x04hits\x12\x16\n" +
	"\x06misses\x18\x02 \x01(\x03R\x06misses\"\xee\x02\n" +
	"\x10PolicySyncStatus\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n" +
	"\n" +
	"match_hits\x18\x02 \x01(\x03R\tmatchHits\x12!\n" +
	"\fmatch_misses\x18\x03 \x01(\x03R\vmatchMisses\x12\x16\n" +
	"\x06errors\x18\x04 \x03(\tR\x06errors\x12<\n" +
	"\x06remove\x18\n" +
	" \x01(\v2$.tero.policy.v1.TransformStageStatusR\x06remove\x12<\n" +
	"\x06redact\x18\v \x01(\v2$.tero.policy.v1.TransformStageStatusR\x06redact\x12<\n" +
	"\x06rename\x18\f \x01(\v2$.tero.policy.v1.TransformStageStatusR\x06rename\x126\n" +
	"\x03add\x18\r \x01(\v2$.tero.policy.v1.TransformStageStatusR\x03add\"\xb2\x02\n" +
	"\vSyncRequest\x12G\n" +
	"\x0fclient_metadata\x18\x01 \x01(\v2\x1e.tero.policy.v1.ClientMetadataR\x0eclientMetadata\x12\x1b\n" +
	"\tfull_sync\x18\x02 \x01(\bR\bfullSync\x12@\n" +
	"\x1dlast_sync_timestamp_unix_nano\x18\x03 \x01(\x06R\x19lastSyncTimestampUnixNano\x120\n" +
	"\x14last_successful_hash\x18\x04 \x01(\tR\x12lastSuccessfulHash\x12I\n" +
	"\x0fpolicy_statuses\x18\x05 \x03(\v2 .tero.policy.v1.PolicySyncStatusR\x0epolicyStatuses\"\xb6\x02\n" +
	"\fSyncResponse\x122\n" +
	"\bpolicies\x18\x01 \x03(\v2\x16.tero.policy.v1.PolicyR\bpolicies\x12\x12\n" +
	"\x04hash\x18\x02 \x01(\tR\x04hash\x127\n" +
	"\x18sync_timestamp_unix_nano\x18\x03 \x01(\x06R\x15syncTimestampUnixNano\x12I\n" +
	"!recommended_sync_interval_seconds\x18\x04 \x01(\rR\x1erecommendedSyncIntervalSeconds\x125\n" +
	"\tsync_type\x18\x05 \x01(\x0e2\x18.tero.policy.v1.SyncTypeR\bsyncType\x12#\n" +
	"\rerror_message\x18\x06 \x01(\tR\ferrorMessage*\xa9\x01\n" +
	"\vPolicyStage\x12\x1c\n" +
	"\x18POLICY_STAGE_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17POLICY_STAGE_LOG_FILTER\x10\x01\x12\x1e\n" +
	"\x1aPOLICY_STAGE_LOG_TRANSFORM\x10\x02\x12\x1e\n" +
	"\x1aPOLICY_STAGE_METRIC_FILTER\x10\x03\x12\x1f\n" +
	"\x1bPOLICY_STAGE_TRACE_SAMPLING\x10\x04*9\n" +
	"\bSyncType\x12\x19\n" +
	"\x15SYNC_TYPE_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eSYNC_TYPE_FULL\x10\x012n\n" +
	"\rPolicyService\x12]\n" +
	"\x04Sync\x12\x1b.tero.policy.v1.SyncRequest\x1a\x1c.tero.policy.v1.SyncResponse\"\x1a\x82\xd3\xe4\x93\x02\x14:\x01*\"\x0f/v1/policy/syncB1Z/github.com/usetero/policy/gen/go/tero/policy/v1b\x06proto3"

var (
	file_tero_policy_v1_policy_proto_rawDescOnce sync.Once
	file_tero_policy_v1_policy_proto_rawDescData []byte
)

func file_tero_policy_v1_policy_proto_rawDescGZIP() []byte {
	file_tero_policy_v1_policy_proto_rawDescOnce.Do(func() {
		file_tero_policy_v1_policy_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tero_policy_v1_policy_proto_rawDesc), len(file_tero_policy_v1_policy_proto_rawDesc)))
	})
	return file_tero_policy_v1_policy_proto_rawDescData
}

var file_tero_policy_v1_policy_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_tero_policy_v1_policy_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_tero_policy_v1_policy_proto_goTypes = []any{
	(PolicyStage)(0),             // 0: tero.policy.v1.PolicyStage
	(SyncType)(0),                // 1: tero.policy.v1.SyncType
	(*Policy)(nil),               // 2: tero.policy.v1.Policy
	(*ClientMetadata)(nil),       // 3: tero.policy.v1.ClientMetadata
	(*TransformStageStatus)(nil), // 4: tero.policy.v1.TransformStageStatus
	(*PolicySyncStatus)(nil),     // 5: tero.policy.v1.PolicySyncStatus
	(*SyncRequest)(nil),          // 6: tero.policy.v1.SyncRequest
	(*SyncResponse)(nil),         // 7: tero.policy.v1.SyncResponse
	(*v1.KeyValue)(nil),          // 8: opentelemetry.proto.common.v1.KeyValue
	(*LogTarget)(nil),            // 9: tero.policy.v1.LogTarget
	(*MetricTarget)(nil),         // 10: tero.policy.v1.MetricTarget
	(*TraceTarget)(nil),          // 11: tero.policy.v1.TraceTarget
}
var file_tero_policy_v1_policy_proto_depIdxs = []int32{
	8,  // 0: tero.policy.v1.Policy.labels:type_name -> opentelemetry.proto.common.v1.KeyValue
	9,  // 1: tero.policy.v1.Policy.log:type_name -> tero.policy.v1.LogTarget
	10, // 2: tero.policy.v1.Policy.metric:type_name -> tero.policy.v1.MetricTarget
	11, // 3: tero.policy.v1.Policy.trace:type_name -> tero.policy.v1.TraceTarget
	0,  // 4: tero.policy.v1.ClientMetadata.supported_policy_stages:type_name -> tero.policy.v1.PolicyStage
	8,  // 5: tero.policy.v1.ClientMetadata.labels:type_name -> opentelemetry.proto.common.v1.KeyValue
	8,  // 6: tero.policy.v1.ClientMetadata.resource_attributes:type_name -> opentelemetry.proto.common.v1.KeyValue
	4,  // 7: tero.policy.v1.PolicySyncStatus.remove:type_name -> tero.policy.v1.TransformStageStatus
	4,  // 8: tero.policy.v1.PolicySyncStatus.redact:type_name -> tero.policy.v1.TransformStageStatus
	4,  // 9: tero.policy.v1.PolicySyncStatus.rename:type_name -> tero.policy.v1.TransformStageStatus
	4,  // 10: tero.policy.v1.PolicySyncStatus.add:type_name -> tero.policy.v1.TransformStageStatus
	3,  // 11: tero.policy.v1.SyncRequest.client_metadata:type_name -> tero.policy.v1.ClientMetadata
	5,  // 12: tero.policy.v1.SyncRequest.policy_statuses:type_name -> tero.policy.v1.PolicySyncStatus
	2,  // 13: tero.policy.v1.SyncResponse.policies:type_name -> tero.policy.v1.Policy
	1,  // 14: tero.policy.v1.SyncResponse.sync_type:type_name -> tero.policy.v1.SyncType
	6,  // 15: tero.policy.v1.PolicyService.Sync:input_type -> tero.policy.v1.SyncRequest
	7,  // 16: tero.policy.v1.PolicyService.Sync:output_type -> tero.policy.v1.SyncResponse
	16, // [16:17] is the sub-list for method output_type
	15, // [15:16] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_tero_policy_v1_policy_proto_init() }
func file_tero_policy_v1_policy_proto_init() {
	if File_tero_policy_v1_policy_proto != nil {
		return
	}
	file_tero_policy_v1_log_proto_init()
	file_tero_policy_v1_metric_proto_init()
	file_tero_policy_v1_trace_proto_init()
	file_tero_policy_v1_policy_proto_msgTypes[0].OneofWrappers = []any{
		(*Policy_Log)(nil),
		(*Policy_Metric)(nil),
		(*Policy_Trace)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tero_policy_v1_policy_proto_rawDesc), len(file_tero_policy_v1_policy_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_tero_policy_v1_policy_proto_goTypes,
		DependencyIndexes: file_tero_policy_v1_policy_proto_depIdxs,
		EnumInfos:         file_tero_policy_v1_policy_proto_enumTypes,
		MessageInfos:      file_tero_policy_v1_policy_proto_msgTypes,
	}.Build()
	File_tero_policy_v1_policy_proto = out.File
	file_tero_policy_v1_policy_proto_goTypes = nil
	file_tero_policy_v1_policy_proto_depIdxs = nil
}
