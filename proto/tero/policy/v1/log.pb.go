// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: tero/policy/v1/log.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// LogField identifies simple log fields (non-keyed).
type LogField int32

const (
	LogField_LOG_FIELD_UNSPECIFIED LogField = 0
	// Log record fields
	LogField_LOG_FIELD_BODY          LogField = 1
	LogField_LOG_FIELD_SEVERITY_TEXT LogField = 2
	LogField_LOG_FIELD_TRACE_ID      LogField = 3
	LogField_LOG_FIELD_SPAN_ID       LogField = 4
	LogField_LOG_FIELD_EVENT_NAME    LogField = 5
	// Schema URLs
	LogField_LOG_FIELD_RESOURCE_SCHEMA_URL LogField = 10
	LogField_LOG_FIELD_SCOPE_SCHEMA_URL    LogField = 11
)

// Enum value maps for LogField.
var (
	LogField_name = map[int32]string{
		0:  "LOG_FIELD_UNSPECIFIED",
		1:  "LOG_FIELD_BODY",
		2:  "LOG_FIELD_SEVERITY_TEXT",
		3:  "LOG_FIELD_TRACE_ID",
		4:  "LOG_FIELD_SPAN_ID",
		5:  "LOG_FIELD_EVENT_NAME",
		10: "LOG_FIELD_RESOURCE_SCHEMA_URL",
		11: "LOG_FIELD_SCOPE_SCHEMA_URL",
	}
	LogField_value = map[string]int32{
		"LOG_FIELD_UNSPECIFIED":         0,
		"LOG_FIELD_BODY":                1,
		"LOG_FIELD_SEVERITY_TEXT":       2,
		"LOG_FIELD_TRACE_ID":            3,
		"LOG_FIELD_SPAN_ID":             4,
		"LOG_FIELD_EVENT_NAME":          5,
		"LOG_FIELD_RESOURCE_SCHEMA_URL": 10,
		"LOG_FIELD_SCOPE_SCHEMA_URL":    11,
	}
)

func (x LogField) Enum() *LogField {
	p := new(LogField)
	*p = x
	return p
}

func (x LogField) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogField) Descriptor() protoreflect.EnumDescriptor {
	return file_tero_policy_v1_log_proto_enumTypes[0].Descriptor()
}

func (LogField) Type() protoreflect.EnumType {
	return &file_tero_policy_v1_log_proto_enumTypes[0]
}

func (x LogField) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogField.Descriptor instead.
func (LogField) EnumDescriptor() ([]byte, []int) {
	return file_tero_policy_v1_log_proto_rawDescGZIP(), []int{0}
}

// LogTarget defines matching and actions for logs.
type LogTarget struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matchers to identify which logs this policy applies to (AND logic)
	Match []*LogMatcher `protobuf:"bytes,1,rep,name=match,proto3" json:"match,omitempty"`
	// The keep field controls whether matching telemetry survives. It unifies
	// dropping, sampling, and rate limiting into a single concept: what percentage
	// or amount of matching telemetry continues to the next stage?
	//
	// Valid values:
	//
	//	"all"  - Keep everything (default, can be omitted)
	//	"none" - Drop everything
	//	"N%"   - Keep N percent (0-100), e.g. "50%"
	//	"N/s"  - Keep at most N per second, e.g. "100/s"
	//	"N/m"  - Keep at most N per minute, e.g. "1000/m"
	Keep string `protobuf:"bytes,2,opt,name=keep,proto3" json:"keep,omitempty"`
	// Transform operations to apply
	Transform *LogTransform `protobuf:"bytes,3,opt,name=transform,proto3" json:"transform,omitempty"`
	// Field to use as the sampling key for consistent sampling.
	// When set, all logs with the same value for this field get the same
	// keep/drop decision. Use for lifecycle events (request_id, trace_id, job_id)
	// to avoid sampling individual log lines independently.
	//
	// Only applies when keep is a sampling value (N%, N/s, N/m).
	// Example: sample_key = log_attribute["request_id"] with keep = "10%" means
	// 10% of requests are kept, with all logs from each kept request preserved.
	SampleKey     *LogSampleKey `protobuf:"bytes,4,opt,name=sample_key,json=sampleKey,proto3" json:"sample_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogTarget) Reset() {
	*x = LogTarget{}
	mi := &file_tero_policy_v1_log_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogTarget) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogTarget) ProtoMessage() {}

func (x *LogTarget) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_log_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogTarget.ProtoReflect.Descriptor instead.
func (*LogTarget) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_log_proto_rawDescGZIP(), []int{0}
}

func (x *LogTarget) GetMatch() []*LogMatcher {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *LogTarget) GetKeep() string {
	if x != nil {
		return x.Keep
	}
	return ""
}

func (x *LogTarget) GetTransform() *LogTransform {
	if x != nil {
		return x.Transform
	}
	return nil
}

func (x *LogTarget) GetSampleKey() *LogSampleKey {
	if x != nil {
		return x.SampleKey
	}
	return nil
}

// LogSampleKey specifies which field to use as the sampling key for consistent
// sampling decisions.
type LogSampleKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// FIELD SELECTION (subset of LogMatcher fields appropriate for sampling keys)
	// The field to use as the sampling key. Exactly one must be set.
	//
	// Types that are valid to be assigned to Field:
	//
	//	*LogSampleKey_LogField
	//	*LogSampleKey_LogAttribute
	//	*LogSampleKey_ResourceAttribute
	//	*LogSampleKey_ScopeAttribute
	Field         isLogSampleKey_Field `protobuf_oneof:"field"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogSampleKey) Reset() {
	*x = LogSampleKey{}
	mi := &file_tero_policy_v1_log_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogSampleKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogSampleKey) ProtoMessage() {}

func (x *LogSampleKey) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_log_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogSampleKey.ProtoReflect.Descriptor instead.
func (*LogSampleKey) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_log_proto_rawDescGZIP(), []int{1}
}

func (x *LogSampleKey) GetField() isLogSampleKey_Field {
	if x != nil {
		return x.Field
	}
	return nil
}

func (x *LogSampleKey) GetLogField() LogField {
	if x != nil {
		if x, ok := x.Field.(*LogSampleKey_LogField); ok {
			return x.LogField
		}
	}
	return LogField_LOG_FIELD_UNSPECIFIED
}

func (x *LogSampleKey) GetLogAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogSampleKey_LogAttribute); ok {
			return x.LogAttribute
		}
	}
	return nil
}

func (x *LogSampleKey) GetResourceAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogSampleKey_ResourceAttribute); ok {
			return x.ResourceAttribute
		}
	}
	return nil
}

func (x *LogSampleKey) GetScopeAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogSampleKey_ScopeAttribute); ok {
			return x.ScopeAttribute
		}
	}
	return nil
}

type isLogSampleKey_Field interface {
	isLogSampleKey_Field()
}

type LogSampleKey_LogField struct {
	// Simple fields (trace_id, span_id, etc.)
	LogField LogField `protobuf:"varint,1,opt,name=log_field,json=logField,proto3,enum=tero.policy.v1.LogField,oneof"`
}

type LogSampleKey_LogAttribute struct {
	// Log record attribute by key or path
	LogAttribute *AttributePath `protobuf:"bytes,2,opt,name=log_attribute,json=logAttribute,proto3,oneof"`
}

type LogSampleKey_ResourceAttribute struct {
	// Resource attribute by key or path
	ResourceAttribute *AttributePath `protobuf:"bytes,3,opt,name=resource_attribute,json=resourceAttribute,proto3,oneof"`
}

type LogSampleKey_ScopeAttribute struct {
	// Scope attribute by key or path
	ScopeAttribute *AttributePath `protobuf:"bytes,4,opt,name=scope_attribute,json=scopeAttribute,proto3,oneof"`
}

func (*LogSampleKey_LogField) isLogSampleKey_Field() {}

func (*LogSampleKey_LogAttribute) isLogSampleKey_Field() {}

func (*LogSampleKey_ResourceAttribute) isLogSampleKey_Field() {}

func (*LogSampleKey_ScopeAttribute) isLogSampleKey_Field() {}

// LogMatcher provides a way to match against log telemetry data using known fields.
//
// IMPORTANT CONSTRAINTS:
//   - Multiple matchers are ANDed together: all matchers must match for the
//     overall match to succeed.
//   - The list of matchers should uniquely identify a specific pattern of telemetry
//     for that policy. Matchers should NOT be used as a catch-all; they should be
//     specific enough to target the intended telemetry precisely.
//
// All regex fields use RE2 syntax for consistency across implementations.
type LogMatcher struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// FIELD SELECTION (keep in sync with LogRedact, LogRename, LogAdd, LogRemove)
	// The field to match against. Exactly one must be set.
	//
	// Types that are valid to be assigned to Field:
	//
	//	*LogMatcher_LogField
	//	*LogMatcher_LogAttribute
	//	*LogMatcher_ResourceAttribute
	//	*LogMatcher_ScopeAttribute
	Field isLogMatcher_Field `protobuf_oneof:"field"`
	// Match type. Exactly one must be set.
	//
	// Types that are valid to be assigned to Match:
	//
	//	*LogMatcher_Exact
	//	*LogMatcher_Regex
	//	*LogMatcher_Exists
	//	*LogMatcher_StartsWith
	//	*LogMatcher_EndsWith
	//	*LogMatcher_Contains
	Match isLogMatcher_Match `protobuf_oneof:"match"`
	// If true, inverts the match result
	Negate bool `protobuf:"varint,20,opt,name=negate,proto3" json:"negate,omitempty"`
	// If true, applies case-insensitive matching to all match types
	CaseInsensitive bool `protobuf:"varint,21,opt,name=case_insensitive,json=caseInsensitive,proto3" json:"case_insensitive,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *LogMatcher) Reset() {
	*x = LogMatcher{}
	mi := &file_tero_policy_v1_log_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogMatcher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogMatcher) ProtoMessage() {}

func (x *LogMatcher) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_log_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogMatcher.ProtoReflect.Descriptor instead.
func (*LogMatcher) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_log_proto_rawDescGZIP(), []int{2}
}

func (x *LogMatcher) GetField() isLogMatcher_Field {
	if x != nil {
		return x.Field
	}
	return nil
}

func (x *LogMatcher) GetLogField() LogField {
	if x != nil {
		if x, ok := x.Field.(*LogMatcher_LogField); ok {
			return x.LogField
		}
	}
	return LogField_LOG_FIELD_UNSPECIFIED
}

func (x *LogMatcher) GetLogAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogMatcher_LogAttribute); ok {
			return x.LogAttribute
		}
	}
	return nil
}

func (x *LogMatcher) GetResourceAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogMatcher_ResourceAttribute); ok {
			return x.ResourceAttribute
		}
	}
	return nil
}

func (x *LogMatcher) GetScopeAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogMatcher_ScopeAttribute); ok {
			return x.ScopeAttribute
		}
	}
	return nil
}

func (x *LogMatcher) GetMatch() isLogMatcher_Match {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *LogMatcher) GetExact() string {
	if x != nil {
		if x, ok := x.Match.(*LogMatcher_Exact); ok {
			return x.Exact
		}
	}
	return ""
}

func (x *LogMatcher) GetRegex() string {
	if x != nil {
		if x, ok := x.Match.(*LogMatcher_Regex); ok {
			return x.Regex
		}
	}
	return ""
}

func (x *LogMatcher) GetExists() bool {
	if x != nil {
		if x, ok := x.Match.(*LogMatcher_Exists); ok {
			return x.Exists
		}
	}
	return false
}

func (x *LogMatcher) GetStartsWith() string {
	if x != nil {
		if x, ok := x.Match.(*LogMatcher_StartsWith); ok {
			return x.StartsWith
		}
	}
	return ""
}

func (x *LogMatcher) GetEndsWith() string {
	if x != nil {
		if x, ok := x.Match.(*LogMatcher_EndsWith); ok {
			return x.EndsWith
		}
	}
	return ""
}

func (x *LogMatcher) GetContains() string {
	if x != nil {
		if x, ok := x.Match.(*LogMatcher_Contains); ok {
			return x.Contains
		}
	}
	return ""
}

func (x *LogMatcher) GetNegate() bool {
	if x != nil {
		return x.Negate
	}
	return false
}

func (x *LogMatcher) GetCaseInsensitive() bool {
	if x != nil {
		return x.CaseInsensitive
	}
	return false
}

type isLogMatcher_Field interface {
	isLogMatcher_Field()
}

type LogMatcher_LogField struct {
	// Simple fields (body, severity_text, trace_id, span_id, etc.)
	LogField LogField `protobuf:"varint,1,opt,name=log_field,json=logField,proto3,enum=tero.policy.v1.LogField,oneof"`
}

type LogMatcher_LogAttribute struct {
	// Log record attribute by key or path
	LogAttribute *AttributePath `protobuf:"bytes,2,opt,name=log_attribute,json=logAttribute,proto3,oneof"`
}

type LogMatcher_ResourceAttribute struct {
	// Resource attribute by key or path
	ResourceAttribute *AttributePath `protobuf:"bytes,3,opt,name=resource_attribute,json=resourceAttribute,proto3,oneof"`
}

type LogMatcher_ScopeAttribute struct {
	// Scope attribute by key or path
	ScopeAttribute *AttributePath `protobuf:"bytes,4,opt,name=scope_attribute,json=scopeAttribute,proto3,oneof"`
}

func (*LogMatcher_LogField) isLogMatcher_Field() {}

func (*LogMatcher_LogAttribute) isLogMatcher_Field() {}

func (*LogMatcher_ResourceAttribute) isLogMatcher_Field() {}

func (*LogMatcher_ScopeAttribute) isLogMatcher_Field() {}

type isLogMatcher_Match interface {
	isLogMatcher_Match()
}

type LogMatcher_Exact struct {
	// Exact string match
	Exact string `protobuf:"bytes,10,opt,name=exact,proto3,oneof"`
}

type LogMatcher_Regex struct {
	// Regular expression match
	Regex string `protobuf:"bytes,11,opt,name=regex,proto3,oneof"`
}

type LogMatcher_Exists struct {
	// Field existence check
	Exists bool `protobuf:"varint,12,opt,name=exists,proto3,oneof"`
}

type LogMatcher_StartsWith struct {
	// Literal prefix match
	StartsWith string `protobuf:"bytes,13,opt,name=starts_with,json=startsWith,proto3,oneof"`
}

type LogMatcher_EndsWith struct {
	// Literal suffix match
	EndsWith string `protobuf:"bytes,14,opt,name=ends_with,json=endsWith,proto3,oneof"`
}

type LogMatcher_Contains struct {
	// Literal substring match
	Contains string `protobuf:"bytes,15,opt,name=contains,proto3,oneof"`
}

func (*LogMatcher_Exact) isLogMatcher_Match() {}

func (*LogMatcher_Regex) isLogMatcher_Match() {}

func (*LogMatcher_Exists) isLogMatcher_Match() {}

func (*LogMatcher_StartsWith) isLogMatcher_Match() {}

func (*LogMatcher_EndsWith) isLogMatcher_Match() {}

func (*LogMatcher_Contains) isLogMatcher_Match() {}

// LogTransform defines modifications to logs.
type LogTransform struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Fields to remove
	Remove []*LogRemove `protobuf:"bytes,1,rep,name=remove,proto3" json:"remove,omitempty"`
	// Fields to redact
	Redact []*LogRedact `protobuf:"bytes,2,rep,name=redact,proto3" json:"redact,omitempty"`
	// Fields to rename
	Rename []*LogRename `protobuf:"bytes,3,rep,name=rename,proto3" json:"rename,omitempty"`
	// Fields to add
	Add           []*LogAdd `protobuf:"bytes,4,rep,name=add,proto3" json:"add,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogTransform) Reset() {
	*x = LogTransform{}
	mi := &file_tero_policy_v1_log_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogTransform) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogTransform) ProtoMessage() {}

func (x *LogTransform) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_log_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogTransform.ProtoReflect.Descriptor instead.
func (*LogTransform) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_log_proto_rawDescGZIP(), []int{3}
}

func (x *LogTransform) GetRemove() []*LogRemove {
	if x != nil {
		return x.Remove
	}
	return nil
}

func (x *LogTransform) GetRedact() []*LogRedact {
	if x != nil {
		return x.Redact
	}
	return nil
}

func (x *LogTransform) GetRename() []*LogRename {
	if x != nil {
		return x.Rename
	}
	return nil
}

func (x *LogTransform) GetAdd() []*LogAdd {
	if x != nil {
		return x.Add
	}
	return nil
}

// LogRemove removes a field.
type LogRemove struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// FIELD SELECTION (keep in sync with LogMatcher, LogRedact, LogRename, LogAdd)
	// The field to remove. Exactly one must be set.
	//
	// Types that are valid to be assigned to Field:
	//
	//	*LogRemove_LogField
	//	*LogRemove_LogAttribute
	//	*LogRemove_ResourceAttribute
	//	*LogRemove_ScopeAttribute
	Field         isLogRemove_Field `protobuf_oneof:"field"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogRemove) Reset() {
	*x = LogRemove{}
	mi := &file_tero_policy_v1_log_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogRemove) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogRemove) ProtoMessage() {}

func (x *LogRemove) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_log_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogRemove.ProtoReflect.Descriptor instead.
func (*LogRemove) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_log_proto_rawDescGZIP(), []int{4}
}

func (x *LogRemove) GetField() isLogRemove_Field {
	if x != nil {
		return x.Field
	}
	return nil
}

func (x *LogRemove) GetLogField() LogField {
	if x != nil {
		if x, ok := x.Field.(*LogRemove_LogField); ok {
			return x.LogField
		}
	}
	return LogField_LOG_FIELD_UNSPECIFIED
}

func (x *LogRemove) GetLogAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogRemove_LogAttribute); ok {
			return x.LogAttribute
		}
	}
	return nil
}

func (x *LogRemove) GetResourceAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogRemove_ResourceAttribute); ok {
			return x.ResourceAttribute
		}
	}
	return nil
}

func (x *LogRemove) GetScopeAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogRemove_ScopeAttribute); ok {
			return x.ScopeAttribute
		}
	}
	return nil
}

type isLogRemove_Field interface {
	isLogRemove_Field()
}

type LogRemove_LogField struct {
	// Simple fields (body, severity_text, trace_id, span_id, etc.)
	LogField LogField `protobuf:"varint,1,opt,name=log_field,json=logField,proto3,enum=tero.policy.v1.LogField,oneof"`
}

type LogRemove_LogAttribute struct {
	// Log record attribute by key or path
	LogAttribute *AttributePath `protobuf:"bytes,2,opt,name=log_attribute,json=logAttribute,proto3,oneof"`
}

type LogRemove_ResourceAttribute struct {
	// Resource attribute by key or path
	ResourceAttribute *AttributePath `protobuf:"bytes,3,opt,name=resource_attribute,json=resourceAttribute,proto3,oneof"`
}

type LogRemove_ScopeAttribute struct {
	// Scope attribute by key or path
	ScopeAttribute *AttributePath `protobuf:"bytes,4,opt,name=scope_attribute,json=scopeAttribute,proto3,oneof"`
}

func (*LogRemove_LogField) isLogRemove_Field() {}

func (*LogRemove_LogAttribute) isLogRemove_Field() {}

func (*LogRemove_ResourceAttribute) isLogRemove_Field() {}

func (*LogRemove_ScopeAttribute) isLogRemove_Field() {}

// LogRedact masks a field value.
type LogRedact struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// FIELD SELECTION (keep in sync with LogMatcher, LogRemove, LogRename, LogAdd)
	// The field to redact. Exactly one must be set.
	//
	// Types that are valid to be assigned to Field:
	//
	//	*LogRedact_LogField
	//	*LogRedact_LogAttribute
	//	*LogRedact_ResourceAttribute
	//	*LogRedact_ScopeAttribute
	Field isLogRedact_Field `protobuf_oneof:"field"`
	// Replacement value (e.g., "[REDACTED]")
	Replacement   string `protobuf:"bytes,10,opt,name=replacement,proto3" json:"replacement,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogRedact) Reset() {
	*x = LogRedact{}
	mi := &file_tero_policy_v1_log_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogRedact) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogRedact) ProtoMessage() {}

func (x *LogRedact) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_log_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogRedact.ProtoReflect.Descriptor instead.
func (*LogRedact) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_log_proto_rawDescGZIP(), []int{5}
}

func (x *LogRedact) GetField() isLogRedact_Field {
	if x != nil {
		return x.Field
	}
	return nil
}

func (x *LogRedact) GetLogField() LogField {
	if x != nil {
		if x, ok := x.Field.(*LogRedact_LogField); ok {
			return x.LogField
		}
	}
	return LogField_LOG_FIELD_UNSPECIFIED
}

func (x *LogRedact) GetLogAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogRedact_LogAttribute); ok {
			return x.LogAttribute
		}
	}
	return nil
}

func (x *LogRedact) GetResourceAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogRedact_ResourceAttribute); ok {
			return x.ResourceAttribute
		}
	}
	return nil
}

func (x *LogRedact) GetScopeAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogRedact_ScopeAttribute); ok {
			return x.ScopeAttribute
		}
	}
	return nil
}

func (x *LogRedact) GetReplacement() string {
	if x != nil {
		return x.Replacement
	}
	return ""
}

type isLogRedact_Field interface {
	isLogRedact_Field()
}

type LogRedact_LogField struct {
	// Simple fields (body, severity_text, trace_id, span_id, etc.)
	LogField LogField `protobuf:"varint,1,opt,name=log_field,json=logField,proto3,enum=tero.policy.v1.LogField,oneof"`
}

type LogRedact_LogAttribute struct {
	// Log record attribute by key or path
	LogAttribute *AttributePath `protobuf:"bytes,2,opt,name=log_attribute,json=logAttribute,proto3,oneof"`
}

type LogRedact_ResourceAttribute struct {
	// Resource attribute by key or path
	ResourceAttribute *AttributePath `protobuf:"bytes,3,opt,name=resource_attribute,json=resourceAttribute,proto3,oneof"`
}

type LogRedact_ScopeAttribute struct {
	// Scope attribute by key or path
	ScopeAttribute *AttributePath `protobuf:"bytes,4,opt,name=scope_attribute,json=scopeAttribute,proto3,oneof"`
}

func (*LogRedact_LogField) isLogRedact_Field() {}

func (*LogRedact_LogAttribute) isLogRedact_Field() {}

func (*LogRedact_ResourceAttribute) isLogRedact_Field() {}

func (*LogRedact_ScopeAttribute) isLogRedact_Field() {}

// LogRename changes a field name.
type LogRename struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// FIELD SELECTION (keep in sync with LogMatcher, LogRemove, LogRedact, LogAdd)
	// The field to rename. Exactly one must be set.
	//
	// Types that are valid to be assigned to From:
	//
	//	*LogRename_FromLogField
	//	*LogRename_FromLogAttribute
	//	*LogRename_FromResourceAttribute
	//	*LogRename_FromScopeAttribute
	From isLogRename_From `protobuf_oneof:"from"`
	// The new field name
	To string `protobuf:"bytes,10,opt,name=to,proto3" json:"to,omitempty"`
	// If true, overwrites the target field if it already exists
	Upsert        bool `protobuf:"varint,11,opt,name=upsert,proto3" json:"upsert,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogRename) Reset() {
	*x = LogRename{}
	mi := &file_tero_policy_v1_log_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogRename) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogRename) ProtoMessage() {}

func (x *LogRename) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_log_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogRename.ProtoReflect.Descriptor instead.
func (*LogRename) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_log_proto_rawDescGZIP(), []int{6}
}

func (x *LogRename) GetFrom() isLogRename_From {
	if x != nil {
		return x.From
	}
	return nil
}

func (x *LogRename) GetFromLogField() LogField {
	if x != nil {
		if x, ok := x.From.(*LogRename_FromLogField); ok {
			return x.FromLogField
		}
	}
	return LogField_LOG_FIELD_UNSPECIFIED
}

func (x *LogRename) GetFromLogAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.From.(*LogRename_FromLogAttribute); ok {
			return x.FromLogAttribute
		}
	}
	return nil
}

func (x *LogRename) GetFromResourceAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.From.(*LogRename_FromResourceAttribute); ok {
			return x.FromResourceAttribute
		}
	}
	return nil
}

func (x *LogRename) GetFromScopeAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.From.(*LogRename_FromScopeAttribute); ok {
			return x.FromScopeAttribute
		}
	}
	return nil
}

func (x *LogRename) GetTo() string {
	if x != nil {
		return x.To
	}
	return ""
}

func (x *LogRename) GetUpsert() bool {
	if x != nil {
		return x.Upsert
	}
	return false
}

type isLogRename_From interface {
	isLogRename_From()
}

type LogRename_FromLogField struct {
	// Simple fields (body, severity_text, trace_id, span_id, etc.)
	FromLogField LogField `protobuf:"varint,1,opt,name=from_log_field,json=fromLogField,proto3,enum=tero.policy.v1.LogField,oneof"`
}

type LogRename_FromLogAttribute struct {
	// Log record attribute by key or path
	FromLogAttribute *AttributePath `protobuf:"bytes,2,opt,name=from_log_attribute,json=fromLogAttribute,proto3,oneof"`
}

type LogRename_FromResourceAttribute struct {
	// Resource attribute by key or path
	FromResourceAttribute *AttributePath `protobuf:"bytes,3,opt,name=from_resource_attribute,json=fromResourceAttribute,proto3,oneof"`
}

type LogRename_FromScopeAttribute struct {
	// Scope attribute by key or path
	FromScopeAttribute *AttributePath `protobuf:"bytes,4,opt,name=from_scope_attribute,json=fromScopeAttribute,proto3,oneof"`
}

func (*LogRename_FromLogField) isLogRename_From() {}

func (*LogRename_FromLogAttribute) isLogRename_From() {}

func (*LogRename_FromResourceAttribute) isLogRename_From() {}

func (*LogRename_FromScopeAttribute) isLogRename_From() {}

// LogAdd inserts a field.
type LogAdd struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// FIELD SELECTION (keep in sync with LogMatcher, LogRemove, LogRedact, LogRename)
	// The field to add. Exactly one must be set.
	//
	// Types that are valid to be assigned to Field:
	//
	//	*LogAdd_LogField
	//	*LogAdd_LogAttribute
	//	*LogAdd_ResourceAttribute
	//	*LogAdd_ScopeAttribute
	Field isLogAdd_Field `protobuf_oneof:"field"`
	// The value to set
	Value string `protobuf:"bytes,10,opt,name=value,proto3" json:"value,omitempty"`
	// If true, overwrites the field if it already exists
	Upsert        bool `protobuf:"varint,11,opt,name=upsert,proto3" json:"upsert,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogAdd) Reset() {
	*x = LogAdd{}
	mi := &file_tero_policy_v1_log_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogAdd) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogAdd) ProtoMessage() {}

func (x *LogAdd) ProtoReflect() protoreflect.Message {
	mi := &file_tero_policy_v1_log_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogAdd.ProtoReflect.Descriptor instead.
func (*LogAdd) Descriptor() ([]byte, []int) {
	return file_tero_policy_v1_log_proto_rawDescGZIP(), []int{7}
}

func (x *LogAdd) GetField() isLogAdd_Field {
	if x != nil {
		return x.Field
	}
	return nil
}

func (x *LogAdd) GetLogField() LogField {
	if x != nil {
		if x, ok := x.Field.(*LogAdd_LogField); ok {
			return x.LogField
		}
	}
	return LogField_LOG_FIELD_UNSPECIFIED
}

func (x *LogAdd) GetLogAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogAdd_LogAttribute); ok {
			return x.LogAttribute
		}
	}
	return nil
}

func (x *LogAdd) GetResourceAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogAdd_ResourceAttribute); ok {
			return x.ResourceAttribute
		}
	}
	return nil
}

func (x *LogAdd) GetScopeAttribute() *AttributePath {
	if x != nil {
		if x, ok := x.Field.(*LogAdd_ScopeAttribute); ok {
			return x.ScopeAttribute
		}
	}
	return nil
}

func (x *LogAdd) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *LogAdd) GetUpsert() bool {
	if x != nil {
		return x.Upsert
	}
	return false
}

type isLogAdd_Field interface {
	isLogAdd_Field()
}

type LogAdd_LogField struct {
	// Simple fields (body, severity_text, trace_id, span_id, etc.)
	LogField LogField `protobuf:"varint,1,opt,name=log_field,json=logField,proto3,enum=tero.policy.v1.LogField,oneof"`
}

type LogAdd_LogAttribute struct {
	// Log record attribute by key or path
	LogAttribute *AttributePath `protobuf:"bytes,2,opt,name=log_attribute,json=logAttribute,proto3,oneof"`
}

type LogAdd_ResourceAttribute struct {
	// Resource attribute by key or path
	ResourceAttribute *AttributePath `protobuf:"bytes,3,opt,name=resource_attribute,json=resourceAttribute,proto3,oneof"`
}

type LogAdd_ScopeAttribute struct {
	// Scope attribute by key or path
	ScopeAttribute *AttributePath `protobuf:"bytes,4,opt,name=scope_attribute,json=scopeAttribute,proto3,oneof"`
}

func (*LogAdd_LogField) isLogAdd_Field() {}

func (*LogAdd_LogAttribute) isLogAdd_Field() {}

func (*LogAdd_ResourceAttribute) isLogAdd_Field() {}

func (*LogAdd_ScopeAttribute) isLogAdd_Field() {}

var File_tero_policy_v1_log_proto protoreflect.FileDescriptor

const file_tero_policy_v1_log_proto_rawDesc = "" +
	"\n" +
	"\x18tero/policy/v1/log.proto\x12\x0etero.policy.v1\x1a\x1btero/policy/v1/shared.proto\"\xca\x01\n" +
	"\tLogTarget\x120\n" +
	"\x05match\x18\x01 \x03(\v2\x1a.tero.policy.v1.LogMatcherR\x05match\x12\x12\n" +
	"\x04keep\x18\x02 \x01(\tR\x04keep\x12:\n" +
	"\ttransform\x18\x03 \x01(\v2\x1c.tero.policy.v1.LogTransformR\ttransform\x12;\n" +
	"\n" +
	"sample_key\x18\x04 \x01(\v2\x1c.tero.policy.v1.LogSampleKeyR\tsampleKey\"\xb0\x02\n" +
	"\fLogSampleKey\x127\n" +
	"\tlog_field\x18\x01 \x01(\x0e2\x18.tero.policy.v1.LogFieldH\x00R\blogField\x12D\n" +
	"\rlog_attribute\x18\x02 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\flogAttribute\x12N\n" +
	"\x12resource_attribute\x18\x03 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x11resourceAttribute\x12H\n" +
	"\x0fscope_attribute\x18\x04 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x0escopeAttributeB\a\n" +
	"\x05field\"\xa4\x04\n" +
	"\n" +
	"LogMatcher\x127\n" +
	"\tlog_field\x18\x01 \x01(\x0e2\x18.tero.policy.v1.LogFieldH\x00R\blogField\x12D\n" +
	"\rlog_attribute\x18\x02 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\flogAttribute\x12N\n" +
	"\x12resource_attribute\x18\x03 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x11resourceAttribute\x12H\n" +
	"\x0fscope_attribute\x18\x04 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x0escopeAttribute\x12\x16\n" +
	"\x05exact\x18\n" +
	" \x01(\tH\x01R\x05exact\x12\x16\n" +
	"\x05regex\x18\v \x01(\tH\x01R\x05regex\x12\x18\n" +
	"\x06exists\x18\f \x01(\bH\x01R\x06exists\x12!\n" +
	"\vstarts_with\x18\r \x01(\tH\x01R\n" +
	"startsWith\x12\x1d\n" +
	"\tends_with\x18\x0e \x01(\tH\x01R\bendsWith\x12\x1c\n" +
	"\bcontains\x18\x0f \x01(\tH\x01R\bcontains\x12\x16\n" +
	"\x06negate\x18\x14 \x01(\bR\x06negate\x12)\n" +
	"\x10case_insensitive\x18\x15 \x01(\bR\x0fcaseInsensitiveB\a\n" +
	"\x05fieldB\a\n" +
	"\x05match\"\xd1\x01\n" +
	"\fLogTransform\x121\n" +
	"\x06remove\x18\x01 \x03(\v2\x19.tero.policy.v1.LogRemoveR\x06remove\x121\n" +
	"\x06redact\x18\x02 \x03(\v2\x19.tero.policy.v1.LogRedactR\x06redact\x121\n" +
	"\x06rename\x18\x03 \x03(\v2\x19.tero.policy.v1.LogRenameR\x06rename\x12(\n" +
	"\x03add\x18\x04 \x03(\v2\x16.tero.policy.v1.LogAddR\x03add\"\xad\x02\n" +
	"\tLogRemove\x127\n" +
	"\tlog_field\x18\x01 \x01(\x0e2\x18.tero.policy.v1.LogFieldH\x00R\blogField\x12D\n" +
	"\rlog_attribute\x18\x02 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\flogAttribute\x12N\n" +
	"\x12resource_attribute\x18\x03 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x11resourceAttribute\x12H\n" +
	"\x0fscope_attribute\x18\x04 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x0escopeAttributeB\a\n" +
	"\x05field\"\xcf\x02\n" +
	"\tLogRedact\x127\n" +
	"\tlog_field\x18\x01 \x01(\x0e2\x18.tero.policy.v1.LogFieldH\x00R\blogField\x12D\n" +
	"\rlog_attribute\x18\x02 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\flogAttribute\x12N\n" +
	"\x12resource_attribute\x18\x03 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x11resourceAttribute\x12H\n" +
	"\x0fscope_attribute\x18\x04 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x0escopeAttribute\x12 \n" +
	"\vreplacement\x18\n" +
	" \x01(\tR\vreplacementB\a\n" +
	"\x05field\"\xf8\x02\n" +
	"\tLogRename\x12@\n" +
	"\x0efrom_log_field\x18\x01 \x01(\x0e2\x18.tero.policy.v1.LogFieldH\x00R\ffromLogField\x12M\n" +
	"\x12from_log_attribute\x18\x02 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x10fromLogAttribute\x12W\n" +
	"\x17from_resource_attribute\x18\x03 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x15fromResourceAttribute\x12Q\n" +
	"\x14from_scope_attribute\x18\x04 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x12fromScopeAttribute\x12\x0e\n" +
	"\x02to\x18\n" +
	" \x01(\tR\x02to\x12\x16\n" +
	"\x06upsert\x18\v \x01(\bR\x06upsertB\x06\n" +
	"\x04from\"\xd8\x02\n" +
	"\x06LogAdd\x127\n" +
	"\tlog_field\x18\x01 \x01(\x0e2\x18.tero.policy.v1.LogFieldH\x00R\blogField\x12D\n" +
	"\rlog_attribute\x18\x02 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\flogAttribute\x12N\n" +
	"\x12resource_attribute\x18\x03 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x11resourceAttribute\x12H\n" +
	"\x0fscope_attribute\x18\x04 \x01(\v2\x1d.tero.policy.v1.AttributePathH\x00R\x0escopeAttribute\x12\x14\n" +
	"\x05value\x18\n" +
	" \x01(\tR\x05value\x12\x16\n" +
	"\x06upsert\x18\v \x01(\bR\x06upsertB\a\n" +
	"\x05field*\xe2\x01\n" +
	"\bLogField\x12\x19\n" +
	"\x15LOG_FIELD_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eLOG_FIELD_BODY\x10\x01\x12\x1b\n" +
	"\x17LOG_FIELD_SEVERITY_TEXT\x10\x02\x12\x16\n" +
	"\x12LOG_FIELD_TRACE_ID\x10\x03\x12\x15\n" +
	"\x11LOG_FIELD_SPAN_ID\x10\x04\x12\x18\n" +
	"\x14LOG_FIELD_EVENT_NAME\x10\x05\x12!\n" +
	"\x1dLOG_FIELD_RESOURCE_SCHEMA_URL\x10\n" +
	"\x12\x1e\n" +
	"\x1aLOG_FIELD_SCOPE_SCHEMA_URL\x10\vB1Z/github.com/usetero/policy/gen/go/tero/policy/v1b\x06proto3"

var (
	file_tero_policy_v1_log_proto_rawDescOnce sync.Once
	file_tero_policy_v1_log_proto_rawDescData []byte
)

func file_tero_policy_v1_log_proto_rawDescGZIP() []byte {
	file_tero_policy_v1_log_proto_rawDescOnce.Do(func() {
		file_tero_policy_v1_log_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tero_policy_v1_log_proto_rawDesc), len(file_tero_policy_v1_log_proto_rawDesc)))
	})
	return file_tero_policy_v1_log_proto_rawDescData
}

var file_tero_policy_v1_log_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_tero_policy_v1_log_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_tero_policy_v1_log_proto_goTypes = []any{
	(LogField)(0),         // 0: tero.policy.v1.LogField
	(*LogTarget)(nil),     // 1: tero.policy.v1.LogTarget
	(*LogSampleKey)(nil),  // 2: tero.policy.v1.LogSampleKey
	(*LogMatcher)(nil),    // 3: tero.policy.v1.LogMatcher
	(*LogTransform)(nil),  // 4: tero.policy.v1.LogTransform
	(*LogRemove)(nil),     // 5: tero.policy.v1.LogRemove
	(*LogRedact)(nil),     // 6: tero.policy.v1.LogRedact
	(*LogRename)(nil),     // 7: tero.policy.v1.LogRename
	(*LogAdd)(nil),        // 8: tero.policy.v1.LogAdd
	(*AttributePath)(nil), // 9: tero.policy.v1.AttributePath
}
var file_tero_policy_v1_log_proto_depIdxs = []int32{
	3,  // 0: tero.policy.v1.LogTarget.match:type_name -> tero.policy.v1.LogMatcher
	4,  // 1: tero.policy.v1.LogTarget.transform:type_name -> tero.policy.v1.LogTransform
	2,  // 2: tero.policy.v1.LogTarget.sample_key:type_name -> tero.policy.v1.LogSampleKey
	0,  // 3: tero.policy.v1.LogSampleKey.log_field:type_name -> tero.policy.v1.LogField
	9,  // 4: tero.policy.v1.LogSampleKey.log_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 5: tero.policy.v1.LogSampleKey.resource_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 6: tero.policy.v1.LogSampleKey.scope_attribute:type_name -> tero.policy.v1.AttributePath
	0,  // 7: tero.policy.v1.LogMatcher.log_field:type_name -> tero.policy.v1.LogField
	9,  // 8: tero.policy.v1.LogMatcher.log_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 9: tero.policy.v1.LogMatcher.resource_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 10: tero.policy.v1.LogMatcher.scope_attribute:type_name -> tero.policy.v1.AttributePath
	5,  // 11: tero.policy.v1.LogTransform.remove:type_name -> tero.policy.v1.LogRemove
	6,  // 12: tero.policy.v1.LogTransform.redact:type_name -> tero.policy.v1.LogRedact
	7,  // 13: tero.policy.v1.LogTransform.rename:type_name -> tero.policy.v1.LogRename
	8,  // 14: tero.policy.v1.LogTransform.add:type_name -> tero.policy.v1.LogAdd
	0,  // 15: tero.policy.v1.LogRemove.log_field:type_name -> tero.policy.v1.LogField
	9,  // 16: tero.policy.v1.LogRemove.log_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 17: tero.policy.v1.LogRemove.resource_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 18: tero.policy.v1.LogRemove.scope_attribute:type_name -> tero.policy.v1.AttributePath
	0,  // 19: tero.policy.v1.LogRedact.log_field:type_name -> tero.policy.v1.LogField
	9,  // 20: tero.policy.v1.LogRedact.log_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 21: tero.policy.v1.LogRedact.resource_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 22: tero.policy.v1.LogRedact.scope_attribute:type_name -> tero.policy.v1.AttributePath
	0,  // 23: tero.policy.v1.LogRename.from_log_field:type_name -> tero.policy.v1.LogField
	9,  // 24: tero.policy.v1.LogRename.from_log_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 25: tero.policy.v1.LogRename.from_resource_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 26: tero.policy.v1.LogRename.from_scope_attribute:type_name -> tero.policy.v1.AttributePath
	0,  // 27: tero.policy.v1.LogAdd.log_field:type_name -> tero.policy.v1.LogField
	9,  // 28: tero.policy.v1.LogAdd.log_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 29: tero.policy.v1.LogAdd.resource_attribute:type_name -> tero.policy.v1.AttributePath
	9,  // 30: tero.policy.v1.LogAdd.scope_attribute:type_name -> tero.policy.v1.AttributePath
	31, // [31:31] is the sub-list for method output_type
	31, // [31:31] is the sub-list for method input_type
	31, // [31:31] is the sub-list for extension type_name
	31, // [31:31] is the sub-list for extension extendee
	0,  // [0:31] is the sub-list for field type_name
}

func init() { file_tero_policy_v1_log_proto_init() }
func file_tero_policy_v1_log_proto_init() {
	if File_tero_policy_v1_log_proto != nil {
		return
	}
	file_tero_policy_v1_shared_proto_init()
	file_tero_policy_v1_log_proto_msgTypes[1].OneofWrappers = []any{
		(*LogSampleKey_LogField)(nil),
		(*LogSampleKey_LogAttribute)(nil),
		(*LogSampleKey_ResourceAttribute)(nil),
		(*LogSampleKey_ScopeAttribute)(nil),
	}
	file_tero_policy_v1_log_proto_msgTypes[2].OneofWrappers = []any{
		(*LogMatcher_LogField)(nil),
		(*LogMatcher_LogAttribute)(nil),
		(*LogMatcher_ResourceAttribute)(nil),
		(*LogMatcher_ScopeAttribute)(nil),
		(*LogMatcher_Exact)(nil),
		(*LogMatcher_Regex)(nil),
		(*LogMatcher_Exists)(nil),
		(*LogMatcher_StartsWith)(nil),
		(*LogMatcher_EndsWith)(nil),
		(*LogMatcher_Contains)(nil),
	}
	file_tero_policy_v1_log_proto_msgTypes[4].OneofWrappers = []any{
		(*LogRemove_LogField)(nil),
		(*LogRemove_LogAttribute)(nil),
		(*LogRemove_ResourceAttribute)(nil),
		(*LogRemove_ScopeAttribute)(nil),
	}
	file_tero_policy_v1_log_proto_msgTypes[5].OneofWrappers = []any{
		(*LogRedact_LogField)(nil),
		(*LogRedact_LogAttribute)(nil),
		(*LogRedact_ResourceAttribute)(nil),
		(*LogRedact_ScopeAttribute)(nil),
	}
	file_tero_policy_v1_log_proto_msgTypes[6].OneofWrappers = []any{
		(*LogRename_FromLogField)(nil),
		(*LogRename_FromLogAttribute)(nil),
		(*LogRename_FromResourceAttribute)(nil),
		(*LogRename_FromScopeAttribute)(nil),
	}
	file_tero_policy_v1_log_proto_msgTypes[7].OneofWrappers = []any{
		(*LogAdd_LogField)(nil),
		(*LogAdd_LogAttribute)(nil),
		(*LogAdd_ResourceAttribute)(nil),
		(*LogAdd_ScopeAttribute)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tero_policy_v1_log_proto_rawDesc), len(file_tero_policy_v1_log_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_tero_policy_v1_log_proto_goTypes,
		DependencyIndexes: file_tero_policy_v1_log_proto_depIdxs,
		EnumInfos:         file_tero_policy_v1_log_proto_enumTypes,
		MessageInfos:      file_tero_policy_v1_log_proto_msgTypes,
	}.Build()
	File_tero_policy_v1_log_proto = out.File
	file_tero_policy_v1_log_proto_goTypes = nil
	file_tero_policy_v1_log_proto_depIdxs = nil
}
